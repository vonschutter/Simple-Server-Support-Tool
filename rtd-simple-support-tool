#!/bin/bash
#::				S I M P L E     S Y S T E M   S U P P O R T    T O O L
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#:: Author(s):   	SLS, KLS, NB.  Buffalo Center, IA & Avarua, Cook Islands
    RTD_Version=2.0-Beta
#::
#::
#::	Purpose: To simplify support tasks
#::		  - Display system information
#::		  - Update system software
#:: 		  - Bakup virtual machines
#::               - Cleanup/Report on PPA's (Ubuntu only)
#::               - Show systems physical location
#::		  - Check if a password you intend to use is for sale on the Darknet
#::
#::     Usage: run the script "bash /path/to/rtd" or if installed in the $PATH; by rtd simply type "rtd" in a terminal.
#::
#::     This script is shared in the hopes that
#::     someone will find it usefull.
#::
#::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
#	NOTE:	This terminal program is written to be readable and documented to a very high degree. The reason is that
#		these apps are seldom changed and when they are, it is usefull to be able to understand why and how
#		things were built. Obviously, this becomes a useful learning tool as well; for all people that want to
#		learn how to write admin scripts. It is a good and necessary practice to document extensively and follow
#		patterns when building your own apps and config scripts. Failing to do so will result in a costly mess
#		for any organization after some years and people turnover.
#
#		As a general rule, we prefer using functions extensively because this makes it easier to manage the script
#		and facilitates several users working on the same scripts over time.
#
#
#	RTD admin scrips are placed in /opt/rtd/scripts. Optionally scripts may use the common
#	functions in _rtd_functions and _rtd_recipies:
#
#	  _rtd_functions -- contain usefull admin functions for scripts, such as "how to install software" on different systems.
#	  _rtd_recipies  -- contain software installation and configuration "recipies".
#
#	Scripts may also be stand-alone if there is a reason for this. This script is written to function independently
#	so that it is easy to copy to many server systems, or just to use once on a remote system. This is accomplished by
#	including all functions and dependency checking in this script; as well as avoidnig relying on external files like
#	*.diff files. As a consequence of the portability benefit this script becomes rather large and time consuming to navigate.
#
#	Taxonomy of this script: we prioritize the use of functions over monolithic script writing, and proper indentation
#	to make the script more readable. Each function shall also be documented to the point of the obvious.
#	Suggested function structure per google guidelines:
#
#	function_descriptive_name () {
#		# Documentation and comments...
#		...code...
#	}
#
#	We also like to log all activity, and to echo status output to the screen in a frienly way. To accomplish this,
#	the table below may be used as appropriate:
#
#				OUTPUT REDIRECTION TABLE
#
#		  || visible in terminal ||   visible in file   || existing
#	  Syntax  ||  StdOut  |  StdErr  ||  StdOut  |  StdErr  ||   file
#	==========++==========+==========++==========+==========++===========
#	    >     ||    no    |   yes    ||   yes    |    no    || overwrite
#	    >>    ||    no    |   yes    ||   yes    |    no    ||  append
#	          ||          |          ||          |          ||
#	   2>     ||   yes    |    no    ||    no    |   yes    || overwrite
#	   2>>    ||   yes    |    no    ||    no    |   yes    ||  append
#	          ||          |          ||          |          ||
#	   &>     ||    no    |    no    ||   yes    |   yes    || overwrite
#	   &>>    ||    no    |    no    ||   yes    |   yes    ||  append
#	          ||          |          ||          |          ||
#	 | tee    ||   yes    |   yes    ||   yes    |    no    || overwrite
#	 | tee -a ||   yes    |   yes    ||   yes    |    no    ||  append
#	          ||          |          ||          |          ||
#	 n.e. (*) ||   yes    |   yes    ||    no    |   yes    || overwrite
#	 n.e. (*) ||   yes    |   yes    ||    no    |   yes    ||  append
#	          ||          |          ||          |          ||
#	|& tee    ||   yes    |   yes    ||   yes    |   yes    || overwrite
#	|& tee -a ||   yes    |   yes    ||   yes    |   yes    ||  append
#
#	Our scripts are also structured in to three major sections: "settings", "functions", and "execute".
#	Settings, contain configurable options for the script. Functions, contain all functions. Execute,
#	contains all the actual logic and control of the script.
#
#
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::



#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::            Script Settings               ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# You may comment out or edit items as you deem necessary.
# Some formatting options for cli graphic display.
export BRANDING="RunTime Data : Simple Support Tool"
export BRANDING_ORG="RTD"
export DIALOG_CANCEL=1
export DIALOG_ESC=255
export HEIGHT=20
export WIDTH=90
export LIST_HEIGHT=12

# Set location to backup virtual machines to. This location must have addequate space
# to store several copies of the virtual machine disks. This may be a network share or
# an external storage or san mount point. If you do non need to backup VMs you can set
# this to blank or ignore it. If you do not have QEMU/KVM installed selecting this
# option to back up Virtual Machines in the menu will do nothing.
VM_BACKUP_TARGET="/mnt/vmdsk/VM_BACKUP"

# Terminal Color Setup definitions. These settings allow the simlified use of
# text colors in the teminal. You may want to echo RED for error or GREEN for OK.
YELLOW="\033[1;33m"
RED="\033[1;31m"
ENDCOLOR="\033[0m"
GREEN="\033[1;32m"
BLUE="\033[1;34m"

# Set the background color of the tool. The appearance of the manu system may
# look different on different systems depending on their default settings.
# Here we define the bacground color for consistency by seting the NEWT_COLORS= option. If "dialog"
# is the desired front end then you may set the DIALOG_COLORS= optoin for preferred colors.
# You may select a front end to the rtd tool below by seting the RTD_GUI= option. This will
# override what is detected and preferred! 
# Valid choices are: "dialog", "whiptail".
RTD_GUI=
export NEWT_COLORS='root=,gray '
# DIALOG_COLORS=WHITE,BLUE,ON

# Details for the ISO image creator. To change from one Ubuntu release to another you
# may change the "RELEASE" option. If you wold like to use the ISO maker to build a custom
# Debian installer you may change the "SOURCE_ISO_URL" option to poit to the Debian location.
# Finally, should you desire using your own preseed template (answers to the install questions)
# you should change the "PRESEED_TEMPLATE" option to point to the location of you own template.
TARGET_ISO_FILE_NAME=
SOURCE_ISO_URL=
SSH_PUBLIC_KEY_FILE=
PUT_ISO_FILE_HERE_WHEN_DONE=
PUT_QCOW_FILE_HERE_WHEN_DONE=
VOLUME_TITLE=


# Set location to where to log information:
# in the system log directory in a file named the same as this script.
LOGFILE="/var/log/${0##*/}.log"
#DBG=#

# Determine log file directory
_ERRLOGFILE="/var/log/${0##*/}-error.log"
_LOGFILE="/var/log/${0##*/}.log"


#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::            Tool Executive Functions      ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# Below please find the executive functions of this script. These are the functions
# that actually do the work requested.
#
#

rtd_oem_ensure_rtd_library_available ()
{
	rtd_library="/opt/rtd/scripts/_rtd_library"
	get_rtd_oem_library ()
	{
		if ( $RTD_GUI --keep-window --title "RTD: Get Parts" --yesno "For this tool to run correctly I need to download the RunTime Data Library file from the internet. Is this OK?" 10 90 ); then
			mkdir -p /opt/rtd/scripts
			wget -q https://github.com/vonschutter/RTD-Build/raw/master/System_Setup/_rtd_library -P /opt/rtd/scripts/
			source $rtd_library || $RTD_GUI --colors --title "\Zb\Z1 ERROR!" --pause  "Failed to download Library! PLEASE check that you are connected to the internet." 10 90 10
			rtd_oem_pause $?
		else
			if ( $RTD_GUI --title "RTD: Get Parts" --no-label "EXIT" --yes-label "Go back" --yesno "Since you have dissalowed me to get the RunTime Data Library, I cannot continue. \n Press [ENTER] to quit" 10 90 ); then
				get_rtd_oem_library 
			else
				exit 1
			fi
		fi
	}

	if [ -f $rtd_library ]; then
		if [[ "$(head $rtd_library |grep Version: | cut -f 3)" > 2 ]]; then 
			source $rtd_library
			rtd_oem_pause $?
		else 
			get_rtd_oem_library && echo -e $GREEN "RunTime Data Library download seems sucessful!" $ENDCOLOR || echo -e $RED "RunTime Data Library download seems FAILED!" $ENDCOLOR
			rtd_oem_pause $?
		fi
	else
		get_rtd_oem_library && echo -e $GREEN "RunTime Data Library download seems sucessful!" $ENDCOLOR || echo -e $RED "RunTime Data Library download seems FAILED!" $ENDCOLOR
		rtd_oem_pause $?
	fi

	echo "RTDFUNCTIONS = $RTDFUNCTIONS"
	if [[ $RTDFUNCTIONS -eq 1 ]]; then
		echo -e $GREEN "RTD Library confirmed that it has loaded!" $ENDCOLOR
	else
		$RTD_GUI --colors --title "\Zb\Z1 ERROR!" --pause "RunTime Data Library did not load scucessfully!! \n Please make sure that you are connected to the internet and that sudo and wget are installed." 10 90 10
		exit 1
	fi
}



rtd_oem_pause() {
	if [ ! $1 -eq 0 ]; then
		read -p "Press  [ ENTER ] to continue:"
	fi
}

ensure_admin () {
	# Function to ensure administrative privileges such that system wide settings
	# or configuration may be done. This function will make the script call itself
	# with sudo if the user ID is not 0 e.g. root.

		[ "$UID" -eq 0 ] || echo -e $YELLOW "The $BLUE $BRANDING $YELLOW needs administrative access..." $ENDCOLOR
		[ "$UID" -eq 0 ] || exec sudo bash "$0" "$@"
		[ "$UID" -eq 0 ] && if xset q &>/dev/null; then xhost local:root ; fi 
}



rtd_oem_check_inet_access ()
{
	if ! hash curl &>/dev/null; then 
		read -t 10 -p "N O T I C E ! --  Could not check for internet connectivity... Please install (curl) web crawler/downloader. Press [ENTER] to continue and [CTRL] + [C] to exit! Continuing in 10 seconds..." 
	else 
		curl ipinfo.io &>/dev/null || ( read -t 10 -p "N O T I C E ! -- NO INTERNET ACCESS: This script may require access to the internet to work properly! Press [ENTER] to continue and [CTRL] + [C] to exit!  Continuing in 10 seconds..." )
	fi
}



check_if_password_p0wned () {
	pass_str=$($RTD_GUI --passwordbox "Please enter your intended password to validate your new password against P0wned DB" 8 78 --title "" 3>&1 1>&2 2>&3)
	result=$(
		sha1=$(echo -n $pass_str | tr -d '\n' | sha1sum); echo "Hash prefix: ${sha1:0:5}"; echo "Hash suffix: ${sha1:5:35}";
		query_result=$(curl https://api.pwnedpasswords.com/range/${sha1:0:5} 2>/dev/null | grep "$(echo "${sha1:5:35}" | tr '[:lower:]' '[:upper:]')");
		printf "Your password appeared %d times for sale in the Darknet per the P0wned online database...." "${query_result#*:}" 2>/dev/null ;
		unset pass_str ;
		)
	display_result "Password P0wned Status"
}


convert_vdi_2_qcow2 () 
{
	# Function to import a VirtualBox image to KVM. qcow is a file format for disk
	# image files used by QEMU, a hosted virtual machine monitor.[1] It stands for
	# "QEMU Copy On Write" and uses a disk storage optimization strategy that delays
	# allocation of storage until it is actually needed. This is the required format for
	# qemu/KVM virtual machines. VDI: This format is the VirtualBox-specific VirtualBox Disk Image
	qemu-img convert -f vdi -O qcow2 $VDI $QCOW2
}


change_disk_pass () 
{
	# Function to change the passphrase fo an encrypted storage device.
	# It will offer to change the first encrypted volume found by blockid.
	# It is unclear how this will work if there are multiple encrypted volumes found.
	clear
	echo -e "$RED""Changing the disk encryption password for your hard drive:""$ENDCOLOR"
	cryptsetup luksChangeKey "$(blkid | grep crypto_LUKS|  cut -d : -f 1)"
	read -p "Press  [ ENTER ] to continue:"
}


rtd_oem_release_upgrade ()
{
	unset result
	TMP_DISC_DIR=$(mktemp -d )
		if hostnamectl |grep "Ubuntu" 2>/dev/null ; then
			echo -e $YELLOW"this may take some time, please be patient!" $ENDCOLOR
			apt clean && apt update -m ; dpkg --configure -a ; apt install -f ; apt dist-upgrade ; apt autoremove --purge
			do-release-upgrade 1> >(tee "$TMP_DISC_DIR"/stdout ) 2> >(tee "$TMP_DISC_DIR"/stderr >&2 )
			result="$( cat "$TMP_DISC_DIR"/stdout; cat "$TMP_DISC_DIR"/stderr)"
			display_result "Release Upgrade Attempt Result: "
			rm -r "$TMP_DISC_DIR" ; unset TMP_DISC_DIR
		elif hostnamectl |grep "Pop!_OS" 2>/dev/null ; then
			echo -e $YELLOW"this may take some time, please be patient!" $ENDCOLOR
			apt clean && apt update -m ; dpkg --configure -a ; apt install -f ; apt dist-upgrade ; apt autoremove --purge
			do-release-upgrade 1> >(tee "$TMP_DISC_DIR"/stdout ) 2> >(tee "$TMP_DISC_DIR"/stderr >&2 )
			result="$( cat "$TMP_DISC_DIR"/stdout; cat "$TMP_DISC_DIR"/stderr)"
			display_result "Release Upgrade Attempt Result: "
			rm -r "$TMP_DISC_DIR" ; unset TMP_DISC_DIR
		elif hostnamectl |grep "Debian" 2>/dev/null ; then
			echo -p $RED"Debian does not provide a upgrade tool..." $ENDCOLOR
			result="Debian does not have an in place upgrade tool. Please edit the /etc/apt/sources.list and use the disd-upgrade option"
			display_result "Release Upgrade Attempt Result: "
		elif hostnamectl |grep "SUSE" 2>/dev/null ; then
			echo -e $YELLOW"this may take some time, please be patient!" $ENDCOLOR
			zypper dup 
		elif hostnamectl |grep "fedora" 2>/dev/null ; then
			releasever=$($RTD_GUI --title "Fedora Upgrade Confirmation" --inputbox "Please enter the Fedora version you want to upgrade to. Please make sure that it has been published. You are currently using: $(hosnamectl)  only numbers are valid" 8 78  3>&1 1>&2 2>&3)
			sudo dnf upgrade --refresh
			sudo dnf install dnf-plugin-system-upgrade
			sudo dnf system-upgrade download --refresh --releasever="$releasever"
			sudo dnf system-upgrade
		else
			read -p "This option requires the program (do-release-upgrade) (Ubuntu) or OpenSUSE (zypper) on your system. Press [Enter] key to return to menu."
		fi
		return 
}


rtd_oem_setup_brand_splash_screen() {
	# Function to brand the installer splash screen for the customized installer
	# downloaded from a ginve vendor. This function expects a few simple peices of information:
	# parameter 1: full path to image file to be branded.
	# parameter 2: quoted text to be incerted.
	image_file_to_brand=$1
	text_to_brand_with=$2

	# Ensure that imagemagik is installed so images can be manipulated.
	check_dependencies imagemagick

	# Default locations and splash screens based on debian and ubuntu, meaning this function will assume you are
	# making an ubuntu or debian boot iso as this is generally what this function was written to do. However these values
	# can be overridden by passing the 2 parameters to this script.
	: "${image_file_to_brand:="$(
		if [ -f $TMP_DISC_DIR/splash.png ]; then
			echo "$TMP_DISC_DIR/splash.png"
		elif  [ -f $TMP_DISC_DIR/isolinux/splash.png ]; then
			echo "$TMP_DISC_DIR/isolinux/splash.png"
		elif [ -f $TMP_DISC_DIR/isolinux/splash.png ]; then
			echo "$TMP_DISC_DIR/isolinux/splash.png"
		fi )" }"

	: "${text_to_brand_with:="$( echo " RunTime Data OEM Install: $PREFERENCE" )" }"

	echo -e $GREEN "found: $image_file_to_brand"  $ENDCOLOR
	echo -e $GREEN "branding with: $text_to_brand_with " $ENDCOLOR

	if [ -f $image_file_to_brand ]; then
		convert $image_file_to_brand -gravity north -stroke '#000C' -strokewidth 3 -annotate 0 "$text_to_brand_with" -stroke none -strokewidth 3 -fill white -annotate 0 " $text_to_brand_with "  edit-out.png
		rm $image_file_to_brand
		mv edit-out.png $image_file_to_brand || echo -e $RED "Image [ $image_file_to_brand ] NOT branded!  " $ENDCOLOR

	fi
}


prepare_environment_for_iso_creation ()
{
	# Function to check that all dependencies are available for manipulating the
	# net install ISO from Ubuntu. Subsequently, the temporary file locations
	# are setup and templates are downloaded.

	#Include the path to where the isofile will be put...
	: "${TARGET_ISO="$PUT_ISO_FILE_HERE_WHEN_DONE/$TARGET_ISO_FILE_NAME"}"
	# Ensure that all needed software, outside of the most rudimantary,
	# is available to us... If not, the script should exit.
	: "${_DEPENDENCIES="dos2unix cpio gzip genisoimage whois pwgen wget fakeroot xorriso"}"
	#set -e
	for i in $_DEPENDENCIES
	do
		check_dependencies $i
	done

	# Find full paths for the binaries needed since if they are recently
	# added, they may not be found in the current $PATH. These statements will be evaluated
	# when the variables are referenced not here because of the ":". FYI...
	: "${BIN_7Z:=$(type -P 7z)}"
	: "${BIN_XORRISO:=$(type -P xorriso)}"
	: "${BIN_CPIO:=$(type -P gnucpio || type -P cpio)}"
	: "${BIN_QEMU_IMG:=$(type -P qemu-img)}"
	: "${BIN_KVM:=$(type -P kvm)}"
	: "${BIN_QEMU_SYSTEM_X86_64:=$(type -P qemu-system-x86_64 )}"
	: "${ISOHDPFX_BIN:=$(locate isohdpfx.bin  | head -n 1)}"
	: "${PUT_ISO_FILE_HERE_WHEN_DONE:="/home/$SUDO_USER/Virtual-DVDs"}"
	: "${PUT_QCOW_FILE_HERE_WHEN_DONE:="/home/$SUDO_USER/Virtual-HDs"}"
	: "${VOLUME_TITLE:="RTD Auto Installer"}"
	: "${SSH_PUBLIC_KEY_FILE:="/home/$SUDO_USER/.ssh/id_rsa.pub"}"
	: "${PERMANENT_DOWNLOAD_DIR:="/home/$SUDO_USER/Virtual-DVDs/Downloaded"}"

	# Find the location of the public key on this machine...
	# This should be updated to create a key if not there...
	if [ ! -f "$SSH_PUBLIC_KEY_FILE" ];
	then
		echo "Error: public SSH key $SSH_PUBLIC_KEY_FILE not found!"
		echo "You will need to setup automatic login using ssh manually each time you build a server with this media."
		read -p "Press [Enter] to continue..."
	fi

	# Setup the required folder structure...
	CURRENT_DIR="$(pwd)"
	SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
	TMP_DOWNLOAD_DIR=$(mktemp -d )
	TMP_DISC_DIR=$(mktemp -d )
	TMP_INITRD_DIR=$(mktemp -d )

	for i in $PUT_QCOW_FILE_HERE_WHEN_DONE\
		$PUT_ISO_FILE_HERE_WHEN_DONE\
		$PERMANENT_DOWNLOAD_DIR
	do
		mkdir -p "$i" && chown "$SUDO_USER":"$SUDO_USER" "$i"
	done
}


rtd_oem_ubuntu_auto_install_iso_builder()
{
	# Function to generate an edited ISO file from a folder.
	# this function expects a minimum of one parameter: ssh-server, ubuntu-desktop, kubuntu-desktop, xubuntu-desktop, lubuntu-desktop etc.
	# By default the server ISO image will be downloaded and manipulated. Optionally this function can be told to use the
	# Ubuntu Desktop ISO instead of the server iso by passing a second parameter:
	# :: function name			:: target	   :: iso version to download
	# rtd_oem_ubuntu_auto_install_iso_builder ubuntu-desktop       desktop
	#
	CONFIG=$1
	ISO_VER=$2
	prepare_environment_for_iso_creation

	# Retreive list of available Ubuntu versions:
	all=$(wget -O- releases.ubuntu.com -q | perl -ne '/Ubuntu (\d+.\d+.\d+)/ && print "$1\n"' | sort -Vu)

	# Ask for desired version to use:
	UBUNTU_VER=$($RTD_GUI \
			--inputbox "Please pick an available ubuntu version by entering it below. Versions to choose from: ${all[*]} If you are not sure just let me choose for you... I will allways choose the latest available version. " \
			8 78 "${all[-1]}" \
			--title "Select Release Version of Ubuntu" \
			3>&1 1>&2 2>&3)
	[ "$UBUNTU_VER" ] || UBUNTU_VER=${all[-1]}

	# Find the precice location of the requested ISO image:
	ISO_URL=$(rtd_oem_find_live_release $UBUNTU_VER ubuntu $ISO_VER)
		echo "requested iso for download : $ISO_URL"
		ISO_FILENAME=$(basename $ISO_URL)
		BASE=$(basename $ISO_URL .iso)


	echo "Checking if $ISO_FILENAME already downloaded..."
	iso=$(find "$PERMANENT_DOWNLOAD_DIR" -name "$ISO_FILENAME")
	if [ ! -e "$iso" ]; then
		echo "$ISO_FILENAME is not in cache, downloading..."
		wget -nc $ISO_URL -P "$PERMANENT_DOWNLOAD_DIR" || read -p "Failure to download ISO file"
		iso="$PERMANENT_DOWNLOAD_DIR/$ISO_FILENAME"
	fi


	mnt="${TMP_DISC_DIR:=$(mktemp -d )}"
	TMP_DISC_DIR=$mnt

	mount $iso $mnt -o user,ro || rtd_oem_pause 1
	cat $mnt/.disk/*info || rtd_oem_pause 1
	auto="$BRANDING_ORG-$CONFIG-auto-install-from-${BASE}"
	echo -e "$YELLOW Creating Installations media: $auto $BLUE"
	if [ ! -e $auto ]; then
		cp -a $mnt $auto
		chmod -R +w $auto
	fi

	echo -e "$YELLOW Unmounting $mnt... $ENDCOLOR"
	umount $mnt || rtd_oem_pause 1
	echo -e "$BLUE Modifying installation instructions...  $BLUE"

	case "$2" in
		desktop | Desktop | live | Live)
			#configure_auto_unattended_ubuntu_live_boot_media $auto $CONFIG && echo -e "$GREEN OK! $ENDCOLOR" || rtd_oem_pause 1

			cat > $auto/isolinux/txt.cfg <<- EOF
				default live-install
				label live-install
				menu label ^^Auto Install Ubuntu $CONFIG
				kernel /casper/vmlinuz
				append  file=/cdrom/preseed.cfg auto=true priority=critical debian-installer/locale=en_US keyboard-configuration/layoutcode=us console-setup/ask_detect=false ubiquity/reboot=true languagechooser/language-name=English countrychooser/shortlist=US localechooser/supported-locales=en_US.UTF-8 boot=casper automatic-ubiquity initrd=/casper/initrd quiet splash noprompt noshell ---
			EOF

			make_preseed_cfg $auto $CONFIG

		;;
		*)
			#configure_auto_unattended_ubuntu_server_boot_media $auto $CONFIG && echo -e "$GREEN OK! $ENDCOLOR" || rtd_oem_pause 1
			cat > $auto/isolinux/isolinux.cfg <<- EOF
				default install
				label install
				gfxmode=791
				ui gfxboot bootlogo
				path
				timeout 100
				menu label ^Auto Install Ubuntu $CONFIG
				kernel /install/vmlinuz
				append file=/cdrom/preseed/ubuntu-server.seed initrd=/install/initrd.gz ks=cdrom:/ks.cfg preseed/file=/cdrom/preseed.cfg --
			EOF

			touch $auto/preseed.cfg
			cat > $auto/boot/grub/grub.cfg <<- 'EOF'
			set timeout=10
			GRUB_GFXMODE="1024x768"
			set menu_color_normal=white/black
			set menu_color_highlight=black/light-gray
			EOF

			make_preseed_cfg $auto $CONFIG

		;;
	esac

	echo -e "$YELLOW Modifying startup instructions...  $BLUE"

	cat >> $auto/ks.cfg <<-EOF
	%post --nochroot
	mkdir -p /target/root/.ssh/
	echo $(cat  $SSH_PUBLIC_KEY_FILE ) >> /target/root/.ssh/authorized_keys
	chown -R root /target/root/.ssh/
	%end
	EOF

	TARGET_ISO="$PUT_ISO_FILE_HERE_WHEN_DONE/$auto.iso"

	rtd_oem_setup_brand_splash_screen $mnt/isolinux/splash.png || rtd_oem_pause 1
	if [[ -f $TARGET_ISO ]]; then
		rm $TARGET_ISO
	fi

	$BIN_XORRISO -as mkisofs -isohybrid-mbr "$ISOHDPFX_BIN" \
		-c isolinux/boot.cat -b isolinux/isolinux.bin \
		-no-emul-boot -boot-load-size 4 -boot-info-table \
		-eltorito-alt-boot -e boot/grub/efi.img -no-emul-boot \
		-isohybrid-gpt-basdat -o "$PUT_ISO_FILE_HERE_WHEN_DONE/$auto.iso" $auto
	rtd_oem_pause $?
	umount -l $mnt
	rm -rf $mnt $auto

	if ($RTD_GUI --title "Media ready" --yesno "Created $auto.iso Would you like to test the new image?." 0 0); then
		echo "User selected Yes, exit status was $?."
		check_dependencies qemu-kvm
		qemu-img create -f qcow2 "$PUT_QCOW_FILE_HERE_WHEN_DONE/$auto.qcow2" 10G
		qemu-system-x86_64 -smp 2 -enable-kvm -m 4G --cdrom "$TARGET_ISO" "$PUT_QCOW_FILE_HERE_WHEN_DONE/$auto.qcow2"
	else
		echo "User selected No, exit status was $?."
	fi
}


download_and_manipulate_iso_debian ()
{
	# ownload_and_manipulate_iso_debian "debian" "openssh-server" "MinecraftTasks"
	# This is a simple command sequence to read the preference of distribution to install
	# and what release to get... then download the network install file from debian
	# and manipulate the iso file to complete the edited instruction in the preseed.cfg...
	: "${TARGET_ISO_FILE_NAME:="$1-$2-mini-netinstall-auto.iso"}"
	: "${SOURCE_ISO_URL:="https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/$(curl --silent  https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/MD5SUMS | \grep -o "debian-.*netinst*.iso" |grep -v mac |grep -v edu)"}"
	: "${SOURCE_FIRMWARE:="http://cdimage.debian.org/cdimage/unofficial/non-free/firmware/buster/current/firmware.zip"}"
	TARGET_ISO="$PUT_ISO_FILE_HERE_WHEN_DONE/$TARGET_ISO_FILE_NAME"
	PREFERENCE=$2

		echo -e $YELLOW Geting install image...
		echo -e $GREEN Download: $SOURCE_ISO_URL $ENDCOLOR

	wget -4  -q --show-progress "$SOURCE_ISO_URL" -O "$TMP_DOWNLOAD_DIR/netboot.iso" && "$BIN_7Z" x "$TMP_DOWNLOAD_DIR/netboot.iso" "-o$TMP_DISC_DIR" || echo -e $RED "FAILED to download and extract $SOURCE_ISO_URL" $ENDCOLOR
		echo -e $BLUE; ls $TMP_DISC_DIR ; echo -e $ENDCOLOR
		echo -e $YELLOW Geting non-free firmware...
		echo -e $GREEN Download: $SOURCE_FIRMWARE $ENDCOLOR
	wget -4  -q --show-progress "$SOURCE_FIRMWARE" -O "$TMP_DOWNLOAD_DIR/firmware.zip" && ( mkdir "$TMP_DISC_DIR/firmware" & "$BIN_7Z" x "$TMP_DOWNLOAD_DIR/firmware.zip" "-o$TMP_DISC_DIR/firmware" )

	echo -e $BLUE ; ls $TMP_DISC_DIR/firmware ; echo -e $ENDCOLOR

	# Load the installation answers template.
		echo -e $YELLOW Getting intall instructions template... $ENDCOLOR
	make_preseed_cfg "$TMP_INITRD_DIR" "$PREFERENCE"

# ------------------- Patch 1 grub .cfg ------------------------ #

patch "$TMP_DISC_DIR/boot/grub/grub.cfg" <<PATCH
11a12
> set timeout=10
PATCH

sed -i s/"menuentry --hotkey=g 'Graphical install' {"/"menuentry --hotkey=g 'Automatic Graphical install' {"/g "$TMP_DISC_DIR/boot/grub/grub.cfg"
sed -i s/"menuentry --hotkey=g 'install' {"/"menuentry --hotkey=g 'Automatic install' {"/g "$TMP_DISC_DIR/boot/grub/grub.cfg"
sed -i s/"menu label ^Graphical install"/"menu label ^Automatic Graphical install"/g "$TMP_DISC_DIR/isolinux/gtk.cfg"
sed -i s/"menu label ^Install"/"menu label ^Automatic Install"/g "$TMP_DISC_DIR/isolinux/txt.cfg"
# -------------------------------------------------------------- #


# ---------------------Patch 2 isolinux.cfg -------------------- #

dos2unix "$TMP_DISC_DIR/isolinux/isolinux.cfg"
patch "$TMP_DISC_DIR/isolinux/isolinux.cfg" <<PATCH_II
7c7
< timeout 0
---
> timeout 100
PATCH_II

# -------------------------------------------------------------- #

	# Edit the installation instructions file...
	sed -i s/oem-replace-me-desktop-selection/$PREFERENCE/g "$TMP_INITRD_DIR/preseed.cfg"
	mkdir "$TMP_INITRD_DIR/custom" && cp "$SSH_PUBLIC_KEY_FILE" "$TMP_INITRD_DIR/custom/userkey.pub" || echo -e $RED "Failed to create $TMP_INITRD_DIR/custom" $ENDCOLOR

# ---------------------Create ssh key service ------------------ #

cat << SSH_KEY_KEYGEN > "$TMP_INITRD_DIR/custom/ssh-host-keygen.service"
[Unit]
Description=OpenSSH Server Key Generation
Before=ssh.service

[Service]
ExecStart=/usr/bin/ssh-keygen -A
Type=oneshot
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
SSH_KEY_KEYGEN

# -------------------------------------------------------------- #

	# Inject created content into the new ISO...
	echo -e $GREEN "# Modify the CLI Installer" $ENDCOLOR
	pushd "$TMP_INITRD_DIR" || echo -e $RED "failed to enter init directory: $TMP_INITRD_DIR" $ENDCOLOR
		gzip -d -c "$TMP_DISC_DIR/install.amd/initrd.gz" > "./initrd"
		echo "./preseed.cfg" | fakeroot "$BIN_CPIO" -o -H newc -A -F "./initrd"
		echo "./task.sh" | fakeroot "$BIN_CPIO" -o -H newc -A -F "./initrd"
		find ./custom | fakeroot "$BIN_CPIO" -o -H newc -A -F ./initrd
		cat ./initrd | gzip -9c > "$TMP_DISC_DIR/install.amd/initrd.gz"
		rm "$TMP_INITRD_DIR/initrd"

		echo -e $GREEN "# Modify the GTK Installer" $ENDCOLOR
		gzip -d -c  "$TMP_DISC_DIR/install.amd/gtk/initrd.gz"  > "./initrd"
		echo "./preseed.cfg" | fakeroot "$BIN_CPIO" -o -H newc -A -F "./initrd"
		echo "./task.sh" | fakeroot "$BIN_CPIO" -o -H newc -A -F "./initrd"
		find "./custom" | fakeroot "$BIN_CPIO" -o -H newc -A -F "./initrd"
		cat "./initrd" | gzip -9c > "$TMP_DISC_DIR/install.amd/gtk/initrd.gz"
	popd || (echo -e $RED "Failed to popd" $ENDCOLOR & rtd_oem_pause 1)

echo "$TMP_INITRD_DIR/initrd"
echo "$TMP_DISC_DIR/install.amd/gtk/initrd.gz"
read -p "check the tmp files now"
	rtd_oem_setup_brand_splash_screen


}

create_iso_image ()
{
	# Function to generate the new ISO file from the extracted and
	# altered original ISO.
	# Delete old iso file if there...
	echo "------ CREATING ISO: $TARGET_ISO    --------"
	if [ -f "$TARGET_ISO" ]; then
		rm -f "$TARGET_ISO"
	fi

	cd "$TMP_DISC_DIR" || echo "failed to enter $TMP_DISC_DIR "
	rm -r '[BOOT]'
	"$BIN_XORRISO" -as mkisofs -r -V "$VOLUME_TITLE" -J -b isolinux.bin -c boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table -input-charset utf-8 -isohybrid-mbr "$ISOHDPFX_BIN" -eltorito-alt-boot -e boot/grub/efi.img -no-emul-boot -isohybrid-gpt-basdat -o "$TARGET_ISO" ./
	chmod 777 "$TARGET_ISO" || read -p "An error may have occurred (review above outout) then: Press [ENTER] to continue:"
}

create_iso_image_debian ()
{
	# Function to generate the new ISO file from the extracted and
	# altered original ISO.
	# Delete old iso file if there...
	echo "------ CREATING ISO: $TARGET_ISO    --------"
	if [ -f "$TARGET_ISO" ]; then
		rm -f "$TARGET_ISO"
	fi

	cd "$TMP_DISC_DIR" || echo "Failed to enter $TMP_DISC_DIR"
	rm -r '[BOOT]'
	"$BIN_XORRISO" -as mkisofs -r -V "$VOLUME_TITLE" -J -b "isolinux/isolinux.bin" -c boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table -input-charset utf-8 -isohybrid-mbr "$ISOHDPFX_BIN" -eltorito-alt-boot -e boot/grub/efi.img -no-emul-boot -isohybrid-gpt-basdat -o "$TARGET_ISO" ./
	chmod 777 "$TARGET_ISO" || read -p "An error may have occurred (review above outout) then: Press [ENTER] to continue:"

	# Test the created ISO file by booting it in a temporary VM using qemu.
	if ($RTD_GUI --title "Media Creation Complete" --yesno "Created $TARGET_ISO . Would you like to test you ISO file?" 10 80); then
    		echo "TESTING $TARGET_ISO."
		check_dependencies qemu-kvm
		"$BIN_QEMU_IMG" create -f qcow2 "$PUT_QCOW_FILE_HERE_WHEN_DONE/$(basename $TARGET_ISO .iso).qcow2" 10G
		qemu-system-x86_64 -smp 2 -enable-kvm -m 4G --cdrom "$PUT_ISO_FILE_HERE_WHEN_DONE/$(basename $TARGET_ISO .iso).iso" "$PUT_QCOW_FILE_HERE_WHEN_DONE/$(basename $TARGET_ISO .iso).qcow2"
	else
    		echo "User selected No, exit status was $?."
	fi
}


make_kvm_virtual_machine_now_from_debian_org () {
	# Function to create a KVM virtual michine disk and define a VM. This function should be
	# used on a Qemu/KVM virtual host that the virtual guest is to be used on.
	# NOTE: QCOW2 is a storage format for virtual .
	# machine disk images QCOW stands for QEMU copy on write. The QCOW2 format decouples the physical storage
	# layer from the virtual layer by adding a mapping between logical and physical blocks.
	# NOTE2: Kernel-based Virtual Machine (KVM) is an open source virtualization technology built into Linux®.
	# Specifically, KVM lets you turn Linux into a hypervisor that allows a host machine to run multiple,
	# isolated virtual environments called guests or virtual machines (VMs). KVM is part of Linux.
	# For complete info: https://www.redhat.com/en/topics/virtualization/what-is-KVM
	# set -e
	# Use the check_dependencies function to make sure the needed software is available.
	# Usage: Either simply call this function to use the defaults or:
	# Call this function with "function" "RAM_SIZE" "DISK_SIZE" "DISK_FORMAT" "DISK_FILE"
	# Omitting any of the arguments will us the default instead.

	for i in qemu-utils qemu-tools qemu-kvm qemu-system-x86
	do
		check_dependencies $i 
	done

	# Lookup specific binaries: use full path since they may just have been added and not in $PATH yet.
	: "${BIN_VIRT_INSTALL:=$(type -p virt-install)}"

	# Discover if the appropriate VM net interface is (default or br'0 - n')
	VIRT_NET="$(if ls /sys/class/net |grep br |grep -v virbr >/dev/null; then echo "bridge:$(ls /sys/class/net)" |grep br ; else echo default;fi)"
	
	# create image and run installer
	"${BIN_VIRT_INSTALL}" --name VDI_Debian_"$CONFIG"_"$RANDOM" \
		--vcpus "${2:-2}" \
		--memory "${3:-2048}" \
		--network "$VIRT_NET" \
		--location=http://ftp.us.debian.org/debian/dists/buster/main/installer-amd64/  \
		--disk size="${4:-20}" \
		--os-variant="${1:-debian10}" \
		--initrd-inject="$PRESEED_FILE" \
		--initrd-inject="$TASK_FILE" \
		--extra-args "ks=file:/$(basename $PRESEED_FILE)" \
		--noautoconsole || read -p "An ERROR has occurred. Please press [ENTER] to continue..."
		#"$RTD_GUI" --backtitle "$BRANDING" --title "NOTICE!" --msgbox "ERROR: -- Building VM using $PRESEED_FILE and internal instruction: ks=file:/$(basename $PRESEED_FILE) Options given were: $1 $2 $3 $4" 10 60
	$RTD_GUI --backtitle "$BRANDING" --title "NOTICE!" --msgbox "The virtual machine is currently being built. You may attach to this server and see the progress at IP: $(hostname -I))" 10 60
}


make_kvm_virtual_machine_now_from_ubuntu_com () {
	# Function to create a KVM virtual michine disk and define a VM. This function should be
	# used on a Qemu/KVM virtual host that the virtual guest is to be used on.
	# NOTE: QCOW2 is a storage format for virtual .
	# machine disk images QCOW stands for QEMU copy on write. The QCOW2 format decouples the physical storage
	# layer from the virtual layer by adding a mapping between logical and physical blocks.
	# NOTE2: Kernel-based Virtual Machine (KVM) is an open source virtualization technology built into Linux®.
	# Specifically, KVM lets you turn Linux into a hypervisor that allows a host machine to run multiple,
	# isolated virtual environments called guests or virtual machines (VMs). KVM is part of Linux.
	# For complete info: https://www.redhat.com/en/topics/virtualization/what-is-KVM
	# set -e
	# Use the check_dependencies function to make sure the needed software is available.
	# Usage: Either simply call this function to use the defaults or:
	# Call this function with "function" "RAM_SIZE" "DISK_SIZE" "DISK_FORMAT" "DISK_FILE"
	# Omitting any of the arguments will us the default instead.

	for i in qemu-utils qemu-tools qemu-kvm qemu-system-x86
	do
		check_dependencies $i 
	done

	# Lookup specific binaries: use full path since they may just have been added and not in $PATH yet.
	: "${BIN_VIRT_INSTALL:=$(type -p virt-install)}"

	# Discover if the appropriate VM net interface is (default or br'0 - n')
	VIRT_NET="$(if ls /sys/class/net |grep br |grep -v virbr >/dev/null; then echo "bridge:$(ls /sys/class/net)" |grep br ; else echo default;fi)"
 
	# create image and run installer
	"${BIN_VIRT_INSTALL}" --name VDI_Ubuntu_"$CONFIG"_"$RANDOM" \
		--vcpus "${2:-2}" \
		--memory "${3:-2048}" \
		--network "$VIRT_NET" \
		--disk size="${4:-20}" \
		--os-variant="${1:-debian10}" \
		--location=http://us.archive.ubuntu.com/ubuntu/dists/focal/main/installer-amd64/ \
		--initrd-inject="$PRESEED_FILE" \
		--initrd-inject="$TASK_FILE" \
		--extra-args "ks=file:/$(basename $PRESEED_FILE)" \
		--noautoconsole || read -p "An ERROR has occurred. Please press [ENTER] to continue..."
		#"$RTD_GUI" --backtitle "$BRANDING" --title "NOTICE!" --msgbox "ERROR: -- Building VM using $PRESEED_FILE and internal instruction: ks=file:/$(basename $PRESEED_FILE) Options given were: $1 $2 $3 $4" 10 60
		#
	$RTD_GUI --backtitle "$BRANDING" --title "NOTICE!" --msgbox "The virtual machine is currently being built. You may attach to this server and see the progress at IP: $(hostname -I))" 10 60
}


make_kvm_virtual_machine_now_from_iso () {
	# Function to create a KVM virtual michine disk and define a VM. This function should be
	# used on a Qemu/KVM virtual host that the virtual guest is to be used on.
	# NOTE: QCOW2 is a storage format for virtual .
	# machine disk images QCOW stands for QEMU copy on write. The QCOW2 format decouples the physical storage
	# layer from the virtual layer by adding a mapping between logical and physical blocks.
	# NOTE2: Kernel-based Virtual Machine (KVM) is an open source virtualization technology built into Linux®.
	# Specifically, KVM lets you turn Linux into a hypervisor that allows a host machine to run multiple,
	# isolated virtual environments called guests or virtual machines (VMs). KVM is part of Linux.
	# For complete info: https://www.redhat.com/en/topics/virtualization/what-is-KVM
	# set -e
	# Use the check_dependencies function to make sure the needed software is available.
	# Usage: Either simply call this function to use the defaults or:
	# Call this function with "function" "RAM_SIZE" "DISK_SIZE" "DISK_FORMAT" "DISK_FILE"
	# Omitting any of the arguments will us the default instead.

	for i in qemu-utils qemu-kvm qemu-system-x86
	do
		check_dependencies $i || $RTD_GUI --backtitle "$BRANDING" --title "NOTICE!" --msgbox "$i is missing from this computer; and I could not install it either..." 10 60
	done

	# Lookup specific binaries: use full path since they may just have been added and not in $PATH yet.
	: "${BIN_QEMU_IMG:=$(type -P qemu-img)}"
	: "${BIN_KVM:=$(type -P kvm)}"
	: "${BIN_QEMU_SYSTEM_X86_64:=$(type -P qemu-system-x86_64 )}"
	: "${BIN_VIRT_INSTALL:=$(type -p virt-install)}"

	#Verify ISO presesnce
		if [[ ! -f "$TARGET_ISO" ]]; then
			$RTD_GUI --backtitle "$BRANDING" --title "NOTICE!" --msgbox "OOOPS! I cannot find the ISO image to build the VM... " 10 60
			show_main_menu
		fi

	# create image and run installer
	virt-install --name VM_Template_"$1"_"$RANDOM" --vcpus "${"2"}" --memory "${"2048"}" --network default --cdrom="$TARGET_ISO" --disk size="${"20"}" --os-variant="${1:-"debian10"}"
	$RTD_GUI --backtitle "$BRANDING" --title "NOTICE!" --msgbox "The virtual machine is currently being built. You may attach to this server and see the progress at IP: $(hostname -I)" 10 60
}


set_install_command () 
{
	# add global install command for portability and convenience
	# If you need to use this script in an rpm based system you could modify the install
	# command here to suit dnf, yum, zypper... By default packages of patternd that do not
	# match should be skipped. Use "export option" so child processes also see the variiables.
	if echo "$OSTYPE" |grep -q "linux" ; then
		if hash pkcon 2>/dev/null; then
			# If package kit is available then prefer this
			echo -e "$YELLOW Setting install options for Package Kit $ENDCOLOR"
			export _INSTCMD="pkcon -y  install"
		elif hash yum 2>/dev/null; then
			# If package kit is not available try yum (RedHat, Cent OS, Fedora)
			echo -e "$YELLOW" "Setting install options for YUM" "$ENDCOLOR"
			export _INSTCMD="yum -y  install"
		elif hash apt 2>/dev/null; then
			# If package kit is not available try apt (Debian, Ubuntu, and all derivatives)
			echo -e "$YELLOW" "Setting install options for DEB" "$ENDCOLOR"
			export _INSTCMD="apt-get -y -qq --allow-change-held-packages --ignore-missing install"
			export DEBIAN_FRONTEND=noninteractive
		elif hash zypper 2>/dev/null; then
			# If package kit is not available try zypper (Open SUSE)
			echo -e "$YELLOW" "Setting install options for ZYPPER" "$ENDCOLOR"
			export _INSTCMD="zypper install -y "
		else
			echo -e "$YELLOW" "This system does not seem to have a software managment system" "$ENDCOLOR"
			exit 1
		fi

	elif [[ "$OSTYPE" == "freebsd"* ]]; then
		echo "Free BSD is currently unsupported... "
		export _INSTCMD="echo I dont know how to install suff on FreeBSD!"
	else
	echo "I have no Idea what this system is"
		export _INSTCMD="Whatever!"
		exit 1
	fi
}


is_software_package_installed () {
	# Function to check if a piece of software is installed. This function will first check
	# if the package manager is deb, zypper or rpm, and then take one parameter passed
	# and evauate if a software package by that name is installed. This function
	# will return a "0" or "1" return based on the package managers return code.
	# Call this function by:
	# is_software_package_installed "package name"
	#                 or
	# is_software_package_installed "$1" if calling this function from a script
	# or another function receiving a parameter.
	#
	if hash yum 2>/dev/null; then
		rpm -q "$1" > /dev/null 2>&1 && return 0 || return 1
	elif hash apt 2>/dev/null; then
		dpkg -l "$1" 2>/dev/null |tail -1 |grep "ii  $1" > /dev/null 2>&1 && return 0 || return 1
	elif hash zypper 2>/dev/null; then
		zypper se "$1" > /dev/null 2>&1 && return 0 || return 1
	else
		return 3
	fi
}


is_software_package_available () {
	# Function to chek if a package is available in whetever repository, and
	# if there return a "0" and if not return a "1" or a "3" if there is no recognizable
	# package manager found. The function expects the name of the package
	# to be a parameter passed to this fuction. Call this function by:
	# is_software_package_available "package name"
	#                 or
	# is_software_package_available "$1" if calling this function from a script
	# or another function receiving a parameter.
	#
	# Supported base distributions: Fedora . SuSE . Debian
	if hash yum 2>/dev/null; then
		yum list available "$1" &> /dev/null && return 0 || return 1
	elif hash apt 2>/dev/null; then
		apt -qq list "$1" 2>/dev/null | grep -q "$1" && return 0 || return 1
	elif hash zypper 2>/dev/null; then
		zypper info "$1" &> /dev/null && return 0 || return 1
	else
		return 3
	fi
}


InstallSoftwareFromRepo () {
	# Function to simplify the installation of software by including all display and
	# installation logic for a given software provider. This should be expanded to include flatpack
	# snap for example. It should be the same consistent way no matter flavor of Linux.
	# This function uses the "$_INSTCMD" to install software. "$_INSTCMD" is defined separatley and could
	# be an RPM or deb string, or even snap or flatpack. A preference order between package system and
	# snap or flatpack use.

	# make some decent display terminal Graphics...
	# This function uses set_install_command and ensure_admin to be able to, and know how to, install a package...
	#
	set_install_command
	ensure_admin
	PAD="--------------------------------------------------"
	LINE=$(printf "%s %s" "$@" "$PAD" | cut -c 1-${#PAD})
	# Test if package name is installed, if not then...
	if ! is_software_package_installed "$@"; then
		if is_software_package_available   "$@"; then
		echo -ne "--- Installing ""$LINE"":" \ & $_INSTCMD "$@" >>"$LOGFILE.log" 2>&1 && printf "%b%-6s%b [ \xE2\x9C\x94 ] $GREEN OK!$ENDCOLOR   \n" ||printf "%b%-6s%b [ ! ] $RED FAILED $ENDCOLOR  \n"
		else
		echo -ne "--- Installing ""$LINE"":" \ && printf "%b%-6s%b [ \xE2\x9C\x94 ] $YELLOW Not available $ENDCOLOR \n"
		fi
	else
		echo -ne "--- Installing ""$LINE"":" \ && printf "%b%-6s%b [ \xE2\x9C\x94 ] $YELLOW Already installed $ENDCOLOR \n"
	fi
}


check_dependencies () {
    # Function to check that a piece of software is installed and if not install it.
    # Works for apt, yum, and rpm based systems currently as long as the package name is the same.
    # The function will take a parameter that is expected to match the software command line name
    # or rather the name of the package. This function now relies on the return value of
    # the function "is_software_package_installed" as it is a more reliable way to see if a package of
    # software is installed according to the package manamgent system rather than the "hash" function
    # that checks if a command is available, since command name and package name are not allways the same...

	#---------------------------------------------------------------
        echo "Validating dependencies and installing them if not there..."
	#---------------------------------------------------------------
        if is_software_package_installed $1 ; then
		echo -e "$YELLOW $1 $ENDCOLOR is present on this system..."
        else
                echo -e "$YELLOW $1 $ENDCOLOR not found: I will try to get it... "
                InstallSoftwareFromRepo $1
                if [ $? != 0 ];
                then
                        echo -e $RED "That install didn't work out so well!"
                        echo -e "Please manually try to add the software since I couldn't do it." $ENDCOLOR
                        exit 1
                fi
        echo "OK Done! Continuing..."
        fi
}


check_menu_availability () {
	# First discover what menu system is installed. Some systems use "dialog" and
	# other systems use whiptail for the terminal to show menus and dialogs.
	# If nothing is found, then make sure it is available before continuing.
	if hash dialog 2>/dev/null ; then
		: "${RTD_GUI:=dialog --clear}"
		export RTD_GUI
	elif hash whiptail 2>/dev/null ; then
		: "${RTD_GUI:="whiptail --fb"}"
		export RTD_GUI
		if ( $RTD_GUI --backtitle "$BRANDING" --title "System Information Menu" --no-button "NO: Use whiptail" --yes-button "YES: Install dialog" --yesno "Please NOTE that we are using WHIPTAIL as a terminal menu system, which is missing several features compared to the default: DIALOG menu system. There are a few reasons we may be using WHIPTAIL instead: I was forced to use it or it is the only terminal menu system available... If you continue with the current WHIPTAIL some things might not work. \n \n May I please try to install the dialog system in stead? . \n  " 20 90 ); then
			RTD_GUI=dialog
			err_no_menu_system_found
		else
			echo "User selected No, exit status was $?."
		fi
	else
		err_no_menu_system_found dialog && return 1 || exit 1
	fi
}



err_no_menu_system_found () {
	echo -e $RED" ______________________________________________________________________ \n There is eiter no way to display menus on this system or you have told me \n to install the default  menu system! \n This is required to display the administrative menus... \n \n     ¯\_( ͡👁️ ͜ʖ ͡👁️)_/¯ \n ______________________________________________________________________ \n"
	echo -e $YELLOW"May I attepmpt to install this ability to your system? \a $ENDCOLOR"
	read -p "Add software: (y/n)?" choice
	case "$choice" in
	y|Y )
		: "${RTD_GUI:=$1}"
		for i in dnf yum zypper apt-get; do
			if hash $i 2>/dev/null; then
				$i install $RTD_GUI -y 
				if $? eq 0 ;  then 
					echo -e $YELLOW"$RTD_GUI installed... exporting..."
					RTD_GUI="dialog --clear"
					export RTD_GUI
					return 0
				fi
			fi
		done
	;;
	n|N ) err_no_menu_system_available ;;
	* ) read -p  "Invalid Selection" && err_no_menu_system_found || exit 1 ;;
	esac
}


rtd_update_system () {
	# System update function. The purpose of this function is to update installed software from
	# distribution reopositories and the newer self contained universal software stores like
	# snap and flatpak. 
	# Function does not expect any argument. However it will respect one argument \"simple\"
	# The simple argument instructs this functions [pkcon] action to display simple output
	# rather than more user friendly output. 
	# Update native software packages; since it is not known what distribution
	# this script is being executed on, it is best to check and see if we are able
	# to perform an update and then do the update...
	# One could choose to check for a supported exact version: e.g. Ubuntu, but we would
	# like to be nice and add value for as many as we can. Specially if it is this easy! :)
	PUBLICATION="$BRANDING Update Manager for Linux"
	VERSION="1.13 (built in)"

	LOGFILE="${LOGFILE:-$0.log}"


	echo -e $GREEN"$PUBLICATION: Version $VERSION" $ENDCOLOR
	echo -e $GREEN"------------------------------------------------" $ENDCOLOR

	echo I am updating software from all channels i can find on the system.
	echo I will update via the native package manager as well as newer formats
	echo -e "like $YELLOW snap $ENDCOLOR and $YELLOW flatpak $ENDCOLOR..."
	echo " "


	log_item ()
	{
		DATE=$(date '+%d/%m/%Y %H:%M:%S');
		echo "$DATE --- : $*" >> "$LOGFILE"
	}


        rtd_software_task ()
        {
		log_item "running rtd_software_task with parameters $*"
		# make some decent display terminal graphics...
		PAD="------------------------------------------"
		LINE=$(printf "%s %s" "$@" "$PAD" | cut -c 1-${#PAD})
		echo -ne "--- Executing $LINE:"\ & "$@" >>"$LOGFILE" 2>&1 && printf "%b%-6s%b [ \xE2\x9C\x94 ] $GREEN OK!$ENDCOLOR   \n" ||printf "%b%-6s%b [ ! ] $RED FAILED $ENDCOLOR  \n"
        }

	if hash pkcon 2>/dev/null; then
		# If package kit is available then prefer this
		if [[ $1 == simple ]]; then disp_option="--plain" ; fi
		echo -e $YELLOW "Using: Package Kit" $ENDCOLOR
		pkcon -y refresh $disp_option 2>> $LOGFILE
		pkcon -y update --autoremove $disp_option 2>> $LOGFILE
	elif hash yum 2>/dev/null; then
		# If package kit is not available try yum (RedHat, Cent OS, Fedora)
		echo -e $YELLOW "Using: YUM" $ENDCOLOR
		rtd_software_task yum -y upgrade 2>> $LOGFILE
	elif hash apt 2>/dev/null; then
		# If package kit is not available try apt (Debian, Ubuntu, and all derivatives)
		echo -e $YELLOW "Using: DEB" $ENDCOLOR
		rtd_software_task apt-get update
		rtd_software_task apt-get upgrade -y
		rtd_software_task apt-get autoremove -y
	elif hash zypper 2>/dev/null; then
		# If package kit is not available try zypper (Open SUSE)
		echo -e $YELLOW "Using: ZYPPER" $ENDCOLOR
		rtd_software_task zypper up -y 2>> $LOGFILE
	else
		echo -e $YELLOW "This system does not seem to have a software managment system" $ENDCOLOR
		exit 1
	fi

	# updating snaps if snap is present on the system...
	if hash snap 2>/dev/null; then
		snap refresh 2>> $LOGFILE
	else
		echo "--- snap software is not present on this system... skipping..."
	fi

	# updating flatpacks if flatpack is present on system...
	if hash flatpak 2>/dev/null; then
		flatpak update -y 2>> $LOGFILE
	else
		echo "--- flatpak software is not present on this system... skipping..."
	fi
}


backup_running_vm ()
{
	# Function to back up all funning virtual machines on the host it is being run on.
	# This function should be called from within this script and down not require any
	# parameters passed.


	do_vm_backup () {
		echo "Atempting backup of the folloing VM's:"
		virsh list
		# To exclude a VM (domain), add "nobackup" to its name and it will be ignored.
		# To rename: shutdown the guest, then use this command: virsh domrename "oldname" "newname".

		DATE=$(date +%Y-%m-%d.%H:%M:%S)
		LOG="/var/log/kvm-backup.$DATE.LOG"
		BACKUPROOT=${VM_BACKUP_TARGET:=/mnt/vmdsk/VM_BACKUP}

		#Get list of all running virtual machines
		DOMAINS=$(virsh list --all | tail -n +3 | awk '{print $2}')

		for DOMAIN in $DOMAINS; do
			echo "-----------WORKER START $DOMAIN-----------" > $LOG
			echo "Starting backup for $DOMAIN on $(date +'%d-%m-%Y %H:%M:%S')"  >> $LOG

			if [[ $DOMAIN == *"nobackup"* ]];then
				echo "Skipping $DOMAIN , because its excluded." > $LOG
				exit 1
			fi

			VMSTATE=$(virsh list --all | grep $DOMAIN | awk '{print $3}')
			if [[ $VMSTATE != "running" ]]; then
				echo "Skipping $DOMAIN , because its not running." > $LOG
				exit 1
			fi

			BACKUPFOLDER=$BACKUPROOT/KVM-BACKUPS/$DOMAIN
			if [[ ! -d $BACKUPFOLDER ]] ; then
				$RTD_GUI
			fi
			mkdir -p "$BACKUPFOLDER"
			TARGETS="$(virsh domblklist "$DOMAIN" --details | grep disk | awk '{print $3}')"
			IMAGES="$(virsh domblklist "$DOMAIN" --details | grep disk | awk '{print $4}')"
			DISKSPEC=""
			for TARGET in $TARGETS; do
				DISKSPEC="$DISKSPEC --diskspec $TARGET,snapshot=external"
			done

			virsh snapshot-create-as --domain "$DOMAIN" --name "backup-$DOMAIN" --no-metadata --atomic --disk-only "$DISKSPEC" >> "$LOG"
			if [ $? -ne 0 ]; then
				echo "Failed to create snapshot for $DOMAIN" > "$LOG"
				exit 1
			fi

			for IMAGE in $IMAGES; do
				NAME=$(basename $IMAGE)
				if test -f "$BACKUPFOLDER/$NAME"; then
				echo "Backup exists, merging only changes to image" > "$LOG"
				rsync -apvz --inplace "$IMAGE" "$BACKUPFOLDER"/"$NAME" >> "$LOG"
				else
				echo "Backup does not exist, creating a full sparse copy" > "$LOG"
				rsync -apvz --sparse "$IMAGE" "$BACKUPFOLDER"/"$NAME" >> "$LOG"
				fi
			done

			BACKUPIMAGES="$(virsh domblklist "$DOMAIN" --details | grep disk | awk '{print $4}')"
			for TARGET in $TARGETS; do
				if virsh blockcommit "$DOMAIN" "$TARGET" --active --pivot >> "$LOG"; then
					echo "Could not merge changes for disk of $TARGET of $DOMAIN. VM may be in invalid state." > "$LOG"
					exit 1
				fi
			done

			for BACKUP in $BACKUPIMAGES; do
				if [[ $BACKUP == *"backup-"* ]];then

				echo "deleted temporary image $BACKUP" > "$LOG"
				rm -f "$BACKUP"
				fi
			done

			virsh dumpxml "$DOMAIN" > "$BACKUPFOLDER"/"$DOMAIN".xml
			echo "-----------WORKER END $DOMAIN-----------" >> "$LOG"
			echo "Finished backup of $DOMAIN at $(date +'%d-%m-%Y %H:%M:%S')" >> "$LOG"
		done
	}

	if hash virsh ; then
		if ($RTD_GUI --title "Virtual Machine Backup" --yesno "Do you want me to back up these VM's?:
		$(virsh list --all)" 0 $WIDTH ); then
			do_vm_backup
		else
			show_manage_vm_gui
		fi
	else
		if ( $RTD_GUI --title "NOTICE!" --yesno "KVM Virtualization is not installed on this machine. May I attempt to install it for you on this machine?" $HEIGHT $WIDTH ) ; then
			check_dependencies qemu-kvm || ( whiptail --title "ERROR!" --msgbox "KVM install failed!" $HEIGHT $WIDTH & show_manage_vm_gui)  && whiptail --title "Notice!" --msgbox "KVM installation completed!"
			check_dependencies virt-goodies || ( whiptail --title "ERROR!" --msgbox "Virt Goodies install failed!" $HEIGHT $WIDTH & show_manage_vm_gui)  && whiptail --title "Notice!" --msgbox "Virt Goodies installation completed!"
			do_vm_backup
		else
			show_manage_vm_gui
		fi
	fi
}


rtd_ppa_checker ()
{
  for f in /etc/apt/sources.list.d/*.list; do
    grep -Po "(?<=^deb\s).*?(?=#|$)" "$f" | while read -r ENTRY ; do
    echo "ENTRY: $ENTRY"
        HOST=$(cut -d/ -f3 <<< "$ENTRY")

        if [ "ppa.launchpad.net" = "$HOST" ]; then
		USER=$(cut -d/ -f4 <<< "$ENTRY")
		PPA=$(cut -d/ -f5 <<< "$ENTRY")
		packageCount=$(awk '$1=="Package:" {if (a[$2]++ == 0) {system("dpkg -l "$2)}}' /var/lib/apt/lists/*"$USER"*"$PPA"*Packages 2>/dev/null | awk '/^ii/' | wc -l)
		echo "PPA: ppa:$USER/$PPA"
		echo "FILENAME: $f"
		echo "$packageCount package(s) installed"
		if [ "$packageCount" -eq 0 ] && [ "$1" == "--delete" ]; then
			sudo rm "$f" && echo "$f deleted"
		fi
		echo
        else
		USER=$(cut -d/ -f3 <<< "$ENTRY")
		PPA=$(cut -d/ -f4 <<< "$ENTRY")
		packageCount=$(awk '$1=="Package:" {if (a[$2]++ == 0) {system("dpkg -l "$2)}}' /var/lib/apt/lists/*"$USER"*Packages 2>/dev/null | awk '/^ii/' | wc -l)
		echo "REPOSITORY: $USER/$PPA"
		echo "FILENAME: $f"
		echo "$packageCount package(s) installed"
		if [ "$packageCount" -eq 0 ] && [ "$1" == "--delete" ]; then
			sudo rm "$f" && echo "$f deleted"
		fi
		echo
        fi
    done
done
}


dl ()
{
	# Function to ease and make consistent the downloading of the non repository packages and
	# install them. It can install any package that Package Kit can manage (available on most Linux dists)
	# It expects one parameter: the complete URL to download from.

	download_url="$1"
	fetch_file () { wget -P /opt/rtd/cache "$download_url" 1>>$_LOGFILE 2>>$_ERRLOGFILE ; }

	echo  "    - getting package $download_url ..."
	if hash wget >/dev/null ; then
		fetch_file
	else
		check_dependencies wget
		fetch_file
	fi

	echo "    - Installing package $(basename "$download_url") ..."
	if hash pkcon >/dev/null ; then
		pkcon install-local -y /opt/rtd/cache/"$(basename "$download_url")" 1>>$_LOGFILE 2>>$_ERRLOGFILE
	else
		check_dependencies packagekit-tools
		pkcon install-local -y /opt/rtd/cache/"$(basename "$download_url")" 1>>$_LOGFILE 2>>$_ERRLOGFILE
	fi
}


rtd_oem_find_live_release()
{
	# This function will return the URL for the version of Debian, Ubuntu server or Destktop requested.
	# 3 parameters are required for this function to know what to do: distro_version/
	# It will also try to read the available iso images and grab the latest or requested iso.
	# Example:
	# Function name 		: distro_version : distro_flavor : live_or_not : desktop_env
	# rtd_oem_find_live_release 	      10              debian         live           kde
	# rtd_oem_find_live_release 	      10              debian         live           cinnamon
	# rtd_oem_find_live_release 	      10              debian         net            ssh-server
	# rtd_oem_find_live_release 	      19.04.2         ubuntu         live
	distro_version="${1:-10}"
	distro_flavor="${2:-debian}"
	live_or_not="${3:-live}"
	desktop_env="${4:-standard}"

	case "$distro_flavor" in
	Ubuntu | ubuntu )
		case "$live_or_not" in
		Live | live | current-live | desktop)
			echo "http://releases.ubuntu.com/$distro_version/$(curl --silent http://releases.ubuntu.com/$distro_version/SHA256SUMS | \grep -o 'ubuntu-.*-desktop-amd64.iso')"
		;;
		server | netinst | net | mini )
			# 18.04 and later need to use the alternative installer
			# since the switch to subiquity
			if [ ${1:0:2} -ge 18 ]; then
				echo "http://cdimage.ubuntu.com/releases/$distro_version/release/ubuntu-$distro_version-live-server-arm64.iso"
			else
				rel=http://releases.ubuntu.com/$1
				echo "$rel/$(curl --silent $rel/MD5SUMS | \grep -o 'ubuntu-.*-server-amd64.iso')"
			fi
		;;
		* )
			$RTD_GUI --backtitle "$BRANDING" --title "ERROR!" --msgbox "You passed the function ${FUNCNAME[0]} the parameters $*. The 4th parameter should be either of: Live | live | current-live | server | netinst | net | mini! Not $live_or_not" 10 60
		;;
		esac
	;;
	Debian | debian)
		case "$live_or_not" in
		Live | live | current-live )
			# Debian renames the current iso images for each release. To get around this when downloading
			# the vesion number must be ignored and the desired flavor of the iso should be grabed.
			case "$desktop_env" in
			kde | gnome | xfce | cinnamon | lxde | lxqt | mate | standard )
				rel=https://cdimage.debian.org/debian-cd/current-live/amd64/iso-hybrid/
				echo "$rel/$(curl --silent $rel/MD5SUMS | \grep -o "debian-.*$desktop_env*.iso")"
			;;
			* )
				$RTD_GUI --backtitle "$BRANDING" --title "ERROR!" --msgbox "You passed the function ${FUNCNAME[0]} the parameters $*. The 4th parameter should be wither of: kde | gnome | xfce | cinnamon | lxde | lxqt | mate | standard! Not $live_or_not " 10 60
			;;
			esac
		;;
		netinst | net | mini )
			# Find and download mini iso...
		;;
		* )
			$RTD_GUI --backtitle "$BRANDING" --title "ERROR!" --msgbox "You passed the function ${FUNCNAME[0]} the parameters $*. The 2nd parameter should be either of: Live | live | current-live | netinst | net | mini ! not $live_or_not" 10 60
		;;
		esac
	;;
	*)
		$RTD_GUI --backtitle "$BRANDING" --title "ERROR!" --msgbox "You passed the function ${FUNCNAME[0]} the parameters $*. The 2nd parameter should be either of: Ubuntu | ubuntu Debian | debian! not $distro_flavor" 10 60
	;;
	esac
}


make_preseed_cfg () {
	# Function to write out a debina preeseed file to a location requested by the first parameter.
	# Other parameters accepted are CONFIG (multiselect de), SRVFUNC (task "Minecraft" "Tasks")
	# some parameters have defaults.
	# Example:
	# functoin_name          location        config          function
	# make_preseed_cfg       /path/to/file   ssh-server      Minecraft

	SAVETO=$1
	CONFIG=$2
	SRVFUNC=${3:-Tasks}
	PRESEED=preseed.cfg
	PRESEED_FILE="$SAVETO/$PRESEED"
	TASK_FILE="$SAVETO/task.sh"
	echo "Writing installation instructions for [$CONFIG] in $SAVETO/$PRESEED"
	touch "$SAVETO/$PRESEED"

	rtd_oem_preseed_ubuntu_cfg_KS_CFG_Options "$SAVETO"
	rtd_oem_preseed_cfg_Unattended_Install "$SAVETO"
	rtd_oem_preseed_cfg_Network_Configuration "$SAVETO"
	rtd_oem_preseed_cfg_Prevent_Install_On_USB "$SAVETO"
	rtd_oem_cfg_Account_Setup "$SAVETO"
	rtd_oem_preseed_cfg_Localization "$SAVETO"
	rtd_oem_preseed_cfg_EFI "$SAVETO"
	rtd_oem_preseed_cfg_GRUB_Bootloader_Installation "$SAVETO"
	rtd_oem_preseed_cfg_Disk_Layout "$SAVETO"
	rtd_oem_preseed_cfg_Package_Selection "$SAVETO" "$CONFIG"
	rtd_oem_cfg_post_task_sequence_default "$SAVETO"
	rtd_oem_preseed_cfg_Addon_"${SRVFUNC}" "$SAVETO"
}



#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::    Internal Confgiration Repository      ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# Below please find the internally stored and maintained configuration cards.
# When creating Linux installation configurations for use in a virtual envoironment
# or for transferring to physical media to install on a laptop or PC; require
# the creation of preseed and kick start configuration files that "answer" the
# installer's questions. These pieces of configuration files are stored below
# such that they may be applied to the actual configuration file as needed and
# wiht variable instructions, for example: what software to install. Any configuration
# item that needs to be written out to a separate file should be stored in this section.



rtd_oem_preseed_ubuntu_cfg_KS_CFG_Options ()
{
	cat > $1/ks.cfg <<- EOF
		# --------------------------------------------------- #
		# KS.CFG Options
		# --------------------------------------------------- #
		# Simple instruction to tell the Ubuntu installer that
		# this is intended to be an unattended install and to only
		# ask critical questions (wich we will answer in this file)
		# Add options here from these instructions:
		#
		# https://pykickstart.readthedocs.io/en/latest/kickstart-docs.html#chapter-2-kickstart-commands-in-fedora
		#
		# Please note that some options in kickstart are superceeded by preseed.
		#
		lang en_US.UTF-8
		keyboard se
		timezone $(cat /etc/timezone)
		install
		text
		cdrom
		bootloader --location=mbr
		zerombr yes
		clearpart --all --initlabel
		skipx
		reboot

		# --------------------------------------------------- #
	EOF
}


rtd_oem_preseed_cfg_Unattended_Install ()
{
	cat >> $1/$PRESEED <<-'EOF'
		# --------------------------------------------------- #
		# Unattended Installation
		# --------------------------------------------------- #
		# Simple instruction to tell the debian installer that
		# this is intended to be an unattended install and to only
		# ask critical questions (wich we will answer in this file)
		d-i auto-install/enable boolean true
		d-i debconf/priority select critical
		# --------------------------------------------------- #
	EOF
}


rtd_oem_preseed_cfg_Network_Configuration ()
{
	cat >> $1/$PRESEED <<-'EOF'

		# --------------------------------------------------- #
		# Network configuration
		# --------------------------------------------------- #
		# Network setup. This can be a static setup or dhcp.
		d-i netcfg/choose_interface select manual
		d-i netcfg/hostname string RTD-Client
		d-i netcfg/get_hostname string unassigned-hostname
		d-i netcfg/get_domain string unassigned-domain
		d-i hw-detect/load_firmware boolean true

		# We want the preconfiguration file to work on systems both with and
		# without sucessful dhcp configuration
		d-i netcfg/dhcp_failed note
		d-i netcfg/dhcp_options select Configure network manually
		# d-i netcfg/dhcp_timeout string 60

		d-i netcfg/wireless_show_essids select manual
		d-i netcfg/wireless_essid string loader
		d-i netcfg/wireless_essid_again string loader
		d-i netcfg/wireless_security_type select wpa
		d-i netcfg/wireless_wpa string letmein1234

		# --------------------------------------------------- #
	EOF
}


rtd_oem_cfg_Account_Setup ()
{
	cat >> $1/$PRESEED <<-'EOF'
		# --------------------------------------------------- #
		# Account setup (temporary user account)
		# --------------------------------------------------- #
		# Setup an initial user and disable root login by default.
		# root login may be re-enabled later by setting a root password.
		# An encrypted password is set here, and should be changed
		# ASAP after the system is built. Preferebly connect to LDAP/AD
		# in a managed environment.
		d-i passwd/root-login boolean false
		d-i passwd/user-fullname string RTD User
		d-i passwd/username string tangarora
		d-i passwd/user-password seen true
		d-i user-setup/allow-password-weak boolean true
		d-i passwd/user-password-crypted password $6$Rn5/UTzjIs68MX$9gz8vmshGlPqse3VoX8dzSfhWxRVoYv1MB6aGRD8xdvztOf.gD.SxxVWkxYrwwbShB9Q14flquK/apbdQJ65t1
		d-i passwd/auto-login boolean true

		# --------------------------------------------------- #
	EOF
}


rtd_oem_preseed_cfg_Prevent_Install_On_USB ()
{
	cat >> $1/$PRESEED <<-'EOF'
		# --------------------------------------------------- #
		# Do NOT install on the USB stick(!)
		# --------------------------------------------------- #
		#
		# The Debian installer will install on the first disk it finds which can
		# sometimes be the USB stick itself. Work around this by rolling our own auto
		# detect logic which disallows installing on USB devices.
		#
		# d-i partman/early_command string [ "$(ls -A /tmp)" ] && umount -l /media || echo "Empty" ;
		d-i partman/early_command string \
			USBDEV=$(mount | grep hd-media | cut -d" " -f1 | sed "s/\(.*\)./\1/");\
			BOOTDEV=$(list-devices disk | grep -v \$USBDEV | head -1);\
			debconf-set partman-auto/disk $BOOTDEV;\
			debconf-set grub-installer/bootdev $BOOTDEV;

		# --------------------------------------------------- #
	EOF
}


rtd_oem_preseed_cfg_EFI ()
{
	cat >> $1/$PRESEED <<-'EOF'
		# --------------------------------------------------- #
		# EFI
		# --------------------------------------------------- #
		#
		# The EFI (Extensible Firmware Interface) system partition is a partition on a data storage device.
		# UEFI provides backward compatibility with legacy systems by reserving the first block (sector) of
		# the partition for compatibility code, effectively creating a legacy boot sector. On legacy BIOS-based
		# systems, the first sector of a partition is loaded into memory and execution is transferred to this code.
		# Here we tell setup to install EFI boot setup if possible so that both NEW and old systems may be handled
		# and the installed system can be started.
		d-i partman-efi/non_efi_system boolean true
		# --------------------------------------------------- #
	EOF
}

rtd_oem_preseed_cfg_Localization ()
{
	cat >> $1/$PRESEED <<-'EOF'

		# --------------------------------------------------- #
		# Localization
		# --------------------------------------------------- #
		# Provide localizaton preferences so that the prefferred
		# language is used for display and formats. Comparable to
		# the MUI in Microsoft environments.
		d-i debian-installer/locale string en_US.UTF-8
		d-i localechooser/supported-locales multiselect en_US.UTF-8, se_SE.UTF-8
		d-i console-setup/ask_detect boolean false
		# --------------------------------------------------- #



		# --------------------------------------------------- #
		# Set Keyboard layout
		# --------------------------------------------------- #
		# Set the prefferred keyboard layout. Keyboards will work
		# regardless, but the letters and symbols may not actually
		# be the ones drawn on the keys. Default is us.
		d-i keyboard-configuration/xkb-keymap select se
		d-i keyboard-configuration/layoutcode string se
		d-i debian-installer/keymap select se
		d-i keymap select se
		d-i console-setup/layoutcode string se
		d-i console-setup/ask_detect boolean false

		# --------------------------------------------------- #

		EOF
}

rtd_oem_preseed_cfg_GRUB_Bootloader_Installation ()
{
	cat >> $1/$PRESEED <<-'EOF'
		# --------------------------------------------------- #
		# GRUB bootloader installation
		# --------------------------------------------------- #
		#
		# Tell the grub-installer to install to the MBR even if it also finds some other
		# OS, which is more likely to allow the newly installed Linux OS to boot without issue.
		d-i grub-installer/only_debian boolean true
		d-i grub-installer/with_other_os boolean true
		# --------------------------------------------------- #
	EOF
}

rtd_oem_preseed_cfg_Disk_Layout ()
{
	cat >> $1/$PRESEED <<-'EOF'
		# --------------------------------------------------- #
		#   Disk layout
		# --------------------------------------------------- #
		#
		## Set option to encrypt the hard disk:
		d-i partman-auto/method string crypto
		d-i partman-crypto/passphrase password letmein1234
		d-i partman-crypto/passphrase-again password letmein1234
		d-i partman-auto-crypto/erase_disks boolean false
		d-i partman-lvm/device_remove_lvm boolean true
		d-i partman-lvm/device_remove_lvm_span boolean true
		d-i partman-auto/purge_lvm_from_device boolean true
		d-i partman-lvm/confirm boolean true
		d-i partman-lvm/confirm_nooverwrite boolean true
		d-i partman-auto-lvm/guided_size string max
		d-i partman-auto-lvm/new_vg_name string crypt
		# d-i partman-auto/disk string /dev/sdb
		d-i partman-auto/choose_recipe select root-encrypted
		d-i partman-auto/expert_recipe string                   \
		root-encrypted ::                                       \
				538 538 1075 free                       \
				$primary                                \
				$iflabel{ gpt }                         \
				$reusemethod{ }                         \
				method{ efi } format{ }                 \
			.                                               \
			500 500 500 ext3                                \
				$primary{ } $bootable{ }                \
				method{ format } format{ }              \
				use_filesystem{ } filesystem{ ext4 }    \
				mountpoint{ /boot }                     \
									\
			.                                               \
			2000 2000 2000 linux-swap                       \
				$lvmok{ } lv_name{ swap }               \
				in_vg { crypt }                         \
				$primary{ }                             \
				method{ swap } format{ }                \
			.                                               \
			500 10000 1000000000 ext4                       \
				$lvmok{ } lv_name{ root }               \
				in_vg { crypt }                         \
				$primary{ }                             \
				method{ format } format{ }              \
				use_filesystem{ } filesystem{ ext4 }    \
				mountpoint{ / }                         \
			.                                               \
			2000 2000 2000 ext4                             \
				$primary{ }                             \
				method{ keep }                          \
				use_filesystem{ } filesystem{ ext4 }    \
				label{ rescuedisk }                     \
			.

		d-i partman-md/device_remove_md boolean true
		d-i partman-md/confirm boolean true
		d-i partman-basicfilesystems/no_mount_point boolean false
		d-i partman-partitioning/confirm_write_new_label boolean true
		d-i partman/choose_partition select finish
		d-i partman/confirm boolean true
		d-i partman/confirm_nooverwrite boolean true
		# --------------------------------------------------- #
	EOF
}

rtd_oem_preseed_cfg_Package_Selection ()
{
	cat >> $1/$PRESEED <<-EOF
		# --------------------------------------------------- #
		# Package selection
		# --------------------------------------------------- #
		# Packages may be selected as groups (meta packages) like kde-desktop or
		# as individual packages. Only one "pkgsel/include" string will be used though!
		# remembder to fit all the packages you want on one line.
		# tasksel tasksel/first multiselect standard options:
		# ubuntu-desktop-minimal kubuntu-desktop, ubuntu-gnome-desktop, lubuntu-desktop, ubuntu-mate-desktop
		# desktop,  gnome-desktop, kde-desktop, cinnamon-desktop, mate-desktop,
		# lxde-desktop, web-server, ssh-server, print-server.
		# The "OEM" line below ist to make it simple to replace the line with a
		# relevant chice of debian role using "sed" or similar.
		tasksel tasksel/first multiselect $2
		d-i pkgsel/include string splash openssh-server virt-what wget spice-vdagent

		# Valid choices for pkgsel/upgrade are: safe-upgrade full-upgrade none
		d-i pkgsel/upgrade select none
		d-i pkgsel/update-policy select unattended-upgrades

		# By default, the system’s locate database will be updated after the
		# installer has finished installing most packages. This may take a while, so
		# if you don’t want it, you can set this to "false" to turn it off.
		# d-i pkgsel/updatedb boolean false
		# --------------------------------------------------- #
	EOF
}

rtd_oem_preseed_cfg_Addon_MinecraftServer()
{
	cat >> $1/$PRESEED <<-'EOF'
		# --------------------------------------------------- #
		# Addon Tasks
		# --------------------------------------------------- #
		d-i preseed/late_command string \
			in-target mkdir -p /etc/systemd/system/getty@tty1.service.d ; \
			in-target echo "***********  Updating Autologin information... ************ "; \
			in-target echo "[Service]" > /etc/systemd/system/getty@tty1.service.d/override.confv ; \
			in-target echo "ExecStart=" >> /etc/systemd/system/getty@tty1.service.d/override.conf ; \
			in-target echo "ExecStart=-/sbin/agetty --noissue --autologin tangarora "%I" "$TERM"" >> /etc/systemd/system/getty@tty1.service.d/override.conf ; \
			in-target echo "Type=idle" >> /etc/systemd/system/getty@tty1.service.d/override.conf ; \
			in-target echo "**********    Seting up minecraft.server to start automatically   ************* " ; \
			in-target echo "bash /home/tangarora/minecraft.server" >> /home/tangarora/.bashrc ; \
			in-target wget https://github.com/vonschutter/RTD-Minecraft-Server-Manager/raw/master/minecraft-server -O /home/tangarora/minecraft.server && chmod +x /home/tangarora/minecraft.server  ; \
			umount -l /media || echo "Empty"; \
			eject || true; \
			echo "------  initial Setup Complete!  ------"

		# Answer the last question
		d-i debian-installer/splash boolean true

		# Option to try to greacefully eject the installation media:
		d-i cdrom-detect/eject boolean true

		# Shutdown machine
		d-i finish-install/reboot_in_progress note

		# --------------------------------------------------- #
	EOF
}

rtd_oem_preseed_cfg_Addon_Tasks ()
{
	cat >> $1/$PRESEED <<-'EOF'
		# --------------------------------------------------- #
		# Addon Tasks
		# --------------------------------------------------- #
		d-i preseed/late_command string \
			mkdir -p /target/opt/rtd/scripts; \
			mkdir -p /target/opt/rtd/log; \
			cp -r /task.sh /target/opt/rtd/scripts/; \
			cp /preseed.cfg /target/opt/rtd/log/; \
			in-target chmod +x /opt/rtd/scripts/task.sh; \
			in-target /opt/rtd/scripts/task.sh; \
			umount -l /media || echo "Empty"; \
			eject || true; \
			echo "------  initial Setup Complete!  ------"

		# Answer the last question
		d-i debian-installer/splash boolean true

		# Option to try to greacefully eject the installation media:
		d-i cdrom-detect/eject boolean true

		# Shutdown machine
		d-i finish-install/reboot_in_progress note

		# --------------------------------------------------- #
	EOF
}


rtd_oem_cfg_post_task_sequence_default ()
{
	cat >> $1/task.sh <<-'EOF'
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::          Script Settings                 ::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	# Variables that govern the behavior or the script and location of files are 

	# Base folder structure for optional administrative commandlets and scripts:
	_RTDSCR=$(if [ -f /opt/rtd/scripts ]; then echo /opt/rtd/scripts ; else ( mkdir -p /opt/rtd/scripts & echo  /opt/rtd/scripts ) ; fi )
	_RTDCACHE=$(if [ -f /opt/rtd/cache ]; then echo /opt/rtd/cache ; else ( mkdir -p /opt/rtd/cache & echo  /opt/rtd/cache ) ; fi )
	_RTDLOGSD=$(if [ -f /opt/rtd/log ]; then echo /opt/rtd/log ; else ( mkdir -p /opt/rtd/log & echo  /opt/rtd/log ) ; fi )

	# Location of base administrative scripts and commandlets to get.
	_RTDSRC=https://github.com/vonschutter/RTD-Build/archive/master.zip

	# Determine log file directory
	_LOGFILE=$_RTDLOGSD/$( basename $0).log
	_OEM_USER=tangarora



	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::          Define tasks to complete        ::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	tell_info() {
		echo "starting post install tasks..." 
		echo "SYSTEM information:"		
		echo "File system information: "  	
		mount 				
		echo "Block Devices: "  		
		lsblk   				
		echo "available space: "  		
		df -h  					
		echo "Process information: "  		
		ps aux 					
	} 



	task_setup_rtd_basics() {
		echo "Linux OS Found: Attempting to get instructions for Linux..." 
		wget -q  $_RTDSRC -P $_RTDCACHE 
		unzip -o -j $_RTDCACHE/master.zip -d $_RTDSCR  -x *.png *.md *.yml *.cmd && rm -v $_RTDCACHE/master.zip
		echo "Instructions sucessfully retrieved..." 
		chmod +x $_RTDSCR/* 
		pushd /bin
		ln -f -s $_RTDSCR/rtd* . 		
		popd
	}


	task_setup_ssh_keys() {
		mkdir  -p --mode=0700 /root/.ssh && cat /opt/rtd/custom/userkey.pub > /root/.ssh/authorized_keys 
		mkdir --mode=0700 /home/tangarora/.ssh && cat /opt/rtd/custom/userkey.pub > /home/tangarora/.ssh/authorized_keys 
		chown -R tangarora /home/tangarora/.ssh && chmod 0700 -R /home/tangarora/.ssh 
	}



	task_setup_oem_run_once() {
		# Task to run the OEM post configuaration on first login. 
		# the OEM post configuration may allow for interaction if desired and would
		# best run on several distributions and in a full graphic environment. 

		cat << CREATE_START_LINK > /etc/xdg/autostart/org.runtimedata.oem.cofig.desktop
		# This will automatically start the RuntTime Data OEM config options on 
		# the first login. Once run this launcher will be moved to the /opt/rtd folder
		# so that subsequent logins will not be plagued by the OEM setup.
		# 
		[Desktop Entry]
		Type=Application
		Exec=sudo /opt/rtd/scripts/rtd-oem-linux-config.sh
		Terminal=true
		Hidden=false
		X-GNOME-Autostart-enabled=true
		Name=RuntimeDataConfigurationMenu
		Comment=OEM
		CREATE_START_LINK

	}



	task_enable_oem_elevate_priv() {
		# Add instruction to a sudoers include file:
		# This should be removed when OEM setup is complete as it would represent a back door... 
		echo "tangarora ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers.d/99_sudo_include_file

		# Check that your sudoers include file passed the visudo syntax checks:
		sudo visudo -cf /etc/sudoers.d/99_sudo_include_file
	}



	task_ensure_oem_auto_login() {
		# task to ensure that the temporary OEM user is loged in for 
		# admin purposes. It is better to install crtail software at this 
		# time since a full graphic environment is avaliable. Also the 
		# step 2 inst the OEM load process is optimally able to run 
		# on several distributions. 


		if [[ -f /etc/lightdm/lightdm.conf ]]; then 
			cp /etc/lightdm/lightdm.conf /etc/lightdm/lightdm.conf.rtd-bak

			cat << OEM_LXDM_LOGIN_OPTION > /etc/lightdm/lightdm.conf
			# This configuration file was created by RTD Setup.
			# You may safely replace this file with the original backed up: 
			# /etc/lightdm/lightdm.conf.rtd-bak
			# If this file is not there, then it wa not there to begin with
			# and you can delete this file. 
			[SeatDefaults]
			autologin-user=$_OEM_USER
			autologin-user-timeout=0
			OEM_LXDM_LOGIN_OPTION

		fi


		if [[ -f /etc/sddm.conf ]]; then 
			cp /etc/sddm.conf /etc/sddm.conf.rtd-bak

			cat << OEM_SDDM_LOGIN_OPTION > /etc/sddm.conf
			# This configuration file was created by RTD Setup.
			# You may safely replace this file with the original backed up: 
			# /etc/sddm.conf.rtd-bak
			# If this file is not there, then it wa not there to begin with
			# and you can delete this file. 
			[Autologin]
			User=$_OEM_USER
			Session=plasma.desktop
			OEM_SDDM_LOGIN_OPTION

		fi


		if [[ -f /etc/gdm3/daemon.conf ]]; then 
			cp /etc/gdm3/daemon.conf /etc/gdm3/daemon.conf.rtd-bak

			cat << OEM_GDM3_LOGIN_OPTION > /etc/gdm3/daemon.conf
			# This configuration file was created by RTD Setup.
			# You may safely replace this file with the original backed up: 
			# /etc/gdm3/daemon.conf.rtd-bak
			# If this file is not there, then it wa not there to begin with
			# and you can delete this file. 
			[daemon]
			AutomaticLoginEnable=True
			AutomaticLogin=$_OEM_USER
			WaylandEnable=false
			OEM_GDM3_LOGIN_OPTION

		fi



	}



	task_oem_ensure_elevated_gui () {
		# Some Debian and other Linux distribution do not allow gui apps to 
		# be run when invoked by "sudo" or in a root (system elevated authority) 
		# environment. To mitigate this some stemp may need to taken. 
		# Will work on Slackware as well as Debian to give root permission to open X programs.
		echo "xhost local:root" >> /home/$_OEM_USER/.bashrc  

		# Allows runing an X program as root
		touch /root/.bashrc
		echo "export XAUTHORITY=/home/$_OEM_USER/.Xauthority" >>/root/.bashrc
	}


	task_oem_autounlock_disk() {
		# Setup automatic unlocking of the encrypted system disk (encryption is default on RTD systems).
		# NOTE: This will render the encryption useless since the key to unlock the encrypted
		# volume will be located on an unencrypted location on the same system as the encrypted volume. 
		# This is the same as locking your door and leaving the key by the door outside. 
		#
		# The intention behind this is to be able to complete all build activites without manual intervention
		# of any kind. The intention is to remove the key file after all administrative tasks are complete. 

		# 1. Back up your initramfs disk
		cp  /boot/initrd.img-$(uname -r)  /boot/initrd.img-$(uname -r).bak

			# cat << OEM_CRYPTLOCK_OPTION > /boot/grub/grub.cfg
			#### BEGIN /etc/grub.d/10_linux ###
			#
			# menuentry 'Debian GNU/Linux, with Linux $(uname -r) (crypto safe)' --class debian --class gnu-linux --class gnu --class os {
			#       load_video
			#       insmod gzio
			#       insmod part_msdos
			#       insmod ext2
			#       set root='hd0,msdos1'
			#       search --no-floppy --fs-uuid --set=root 2a5e9b7f-2128-4a50-83b6-d1c285410145
			#       echo    'Loading Linux $(uname -r) ...'
			#       linux   /vmlinuz-$(uname -r) root=/dev/mapper/dradispro-root ro  quiet
			#       echo    'Loading initial ramdisk ...'
			#       initrd  /initrd.img-$(uname -r).safe
			# }
			# ...
			### END /etc/grub.d/10_linux ###
			# OEM_CRYPTLOCK_OPTION

		# 2. Create the key file in the unencrypted /boot partition
		dd if=/dev/urandom of=/boot/keyfile bs=1024 count=4

		# 3. Set permissions
		chmod 0400 /boot/keyfile

		# 4. Add the new file as unlock key to the encrypted volume
		echo letmein1234 | cryptsetup -v luksAddKey $(blkid | grep crypto_LUKS|  cut -d : -f 1) /boot/keyfile -

		# 6. Edit /etc/crypttab
		chmod 0777 /etc/crypttab
		cp /etc/crypttab /etc/crypttab.temporary
		sed -i /"$(cat /etc/crypttab | cut -d " " -f 1 )"/d /etc/crypttab.temporary 
		echo $(cat /etc/crypttab | cut -d " " -f 1-2)  /$(udevadm info $(blkid | grep crypto_LUKS|  cut -d : -f 1) |grep by-uuid | cut -d : -f 2 | head -1):/keyfile luks,keyscript=/lib/cryptsetup/scripts/pa$  >> /etc/crypttab.temporary
		mv /etc/crypttab /etc/crypttab.back
		mv /etc/crypttab.temporary /etc/crypttab

		# Restore permissions to crypttab
		chmod 0440 /etc/crypttab

		# Generate new initramfs
		mkinitramfs -o /boot/initrd.img-$(uname -r)  $(uname -r)

	}


	task_rtd_oem_reseal () {

		if cat /etc/os-release |grep ubuntu ; then
			InstallSoftwareFromRepo oem-config
		elif cat /etc/os-release |grep debian ; then
			echo "I dont know of any OEM configuration for Debian"
		elif cat /etc/os-release |grep suse ; then
			echo "I dont know of any OEM configuration for SuSE"
		elif cat /etc/os-release |grep fedora ; then
			echo "I dont know of any OEM configuration for Fedora"	
		fi
	}




	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::          Execute tasks                   ::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	tell_info			&>> $_LOGFILE
	task_setup_rtd_basics		&>> $_LOGFILE
	task_setup_ssh_keys		&>> $_LOGFILE
	task_setup_oem_run_once		&>> $_LOGFILE
	task_enable_oem_elevate_priv	&>> $_LOGFILE
	task_ensure_oem_auto_login	&>> $_LOGFILE
	task_oem_ensure_elevated_gui	&>> $_LOGFILE
	task_rtd_oem_reseal		&>> $_LOGFILE
	#task_oem_autounlock_disk	&>> $_LOGFILE

	EOF
}

cleanup_and_finish () {
	# Function to remove all temporary file locations left over from building
	# the new netinstall ISO etc. and clean  up some variables...
	# go back to initial directory
	cd "$CURRENT_DIR" && echo "returned to $CURRENT_DIR" || echo "No directory to return to... never mind."
	# Cleanup folder structure...
	rm -r "$TMP_DOWNLOAD_DIR"
	rm -r "$TMP_DISC_DIR"
	rm -r "$TMP_INITRD_DIR"
	rm -r "$SCRIPT_DIR/custom"

	if [[  "$1" != "nomessage" ]]; then
		COMPLETION_MESSAGE="	Your ISO image is ready!
		It is placed in the folder: $PUT_ISO_FILE_HERE_WHEN_DONE/

		Next steps:
		- Burn the ISO to a USB (ex: using MULTIBOOT from Pendrive Linux)
		- If you are using Virtual Machines select the ISO as install media
		- Boot from the media created: allow it to install the system
		- login as the temporary user (temporary password: letmein)
		- Adjust passwords for the encrypted volume and login... "

		$RTD_GUI --backtitle "RTD OEM System Builder" --title "DONE" --msgbox "$COMPLETION_MESSAGE" 15 80
	else
		#silent
		echo "Cleanup..."
	fi

	# Print COMPLETION_MESSAGE
	unset BIN_7Z
	unset BIN_XORRISO
	unset BIN_CPIO
	unset ISOHDPFX_BIN
	unset VOLUME_TITLE
	unset TARGET_ISO_FILE_NAME
	unset SOURCE_ISO_URL
	unset SSH_PUBLIC_KEY_FILE
	unset PRESEED_TEMPLATE
	unset CONFIG
	clear
	return
}


generate_report_disk_space_used_by_directory () {
	# Function to generate a report for folders' disk space use. 
	# This function requres one argument; what root folder to analyse the directories in. 
	# This functio will return a report contained in the variable $return that may then be used.
	# Example: 
	# generate_report_disk_space_used_by_directory /home
	# 
	# This will generate a report on the disk space per directory in the /home folder.
	#
	DIRS=$(ls $1 )
	store=/$tmp/out.ct
	$RTD_GUI --backtitle "$BRANDING" --title "Generating report for: $1" --gauge "Calculating disk space: this may take some time" $HEIGHT $WIDTH < <(
		echo "Storage Utilization Report:" >>$store
		echo "______________________________" >>$store
		n=$(ls $1 | wc -l ) 
		i=0
		for f in $DIRS
		do
			du -cksh $1/$f | grep -v total >>$store
			PCT=$(( 100*(++i)/n ))
			cat <<-EOF
			XXX
			$PCT
			Completed calculation for: "$f"...
			XXX
			EOF
			sleep 1
		done
	)
	total=$(echo ----- >>$store && du -cksh $1 |grep total >>$store) | $RTD_GUI --backtitle "$BRANDING" --title "Completing report..." --progressbox "Working..." $HEIGHT $WIDTH 
	result="$(cat $store )" ; rm $store
}




#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::            Tool GUI Functions            ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# Functions that control how the the RTD menus are displayed are listed below
# in this section for better manageability. When scripts become rather large
# they become cumbersome to manage, then it is sometimes helpful to sections
# in some logical order.
BRAND="  $BRANDING		Verson:$RTD_Version : on $HOSTNAME"
BRANDING=$BRAND

display_result () {
	$RTD_GUI --backtitle "$BRANDING" --title "$1" --msgbox "$result" $HEIGHT $WIDTH 
}


display_notice () {
	# Function to display a notice that the ISO creation is complete.
	# And describe what to de next.
	$RTD_GUI --backtitle "$BRANDING" \
	--title "About" \
	--msgbox "
This tool is part of the RTD System Support Tools. The purpose of this tool is to generate an unattended installation ISO file that can be used directly by a virtual machine in KVM, Oracle Virtual Box, or VMware. Alternatively, this Image may be appled to a thumb drive using "dd" or "etcher", or burned to optical media using "K3B" or another favorite CD/DVD burining software.

This script will:
  - Download the latest installation image
  - Patch the installation media with the instructions to auto-install.
  - The instructios will encrypt the hard drive and install, automatically.
  - The default disk encryption password is: 'letmein1234'
  - The default system login and admin temporary password is: 'letmein'
  - The defaults will be dused if you make no other active choices"  $HEIGHT $WIDTH $LIST_HEIGHT
}


show_notice_on_fist_run () {
	if [ -f ~/.config/rtd-first-run-$RTD_Version ]; then
		echo $RTD_Version has been used already and terms reviewed...
	else
		show_notice_on_fist_run_TEXT="
This looks like the first time you run this vesion of the RTD tools. Please note that these tools are provided as-is and for modification.

The RTD tools run in a separate terminal that you can re connect to if you should get disconnected. This can be done by:
- re-connecting to the server with ssh
- then running command "byobu" if a session is already running on the server"

		$RTD_GUI --backtitle "$BRANDING" --title "DONE" --msgbox "$show_notice_on_fist_run_TEXT" 15 80
		mkdir -p ~/.config ; touch ~/.config/rtd-first-run-$RTD_Version
		clear
	fi


}


rtd_setup_choices_preseed () {
	# Function to write out a debina preeseed file to a location requested by the first parameter.
	# Other parameters accepted are CONFIG (multiselect de), SRVFUNC (task "Minecraft" "Tasks")
	# some parameters have defaults.
	# Example:
	# functoin_name          location        config          function
	# make_preseed_cfg       /path/to/file   ssh-server      Minecraft

	SAVETO=$1
	CONFIG=$2
	SRVFUNC=$3
	: "${SRVFUNC:=Tasks}"
	: "${PRESEED:=preseed.cfg}"
	PRESEED_FILE="$SAVETO/$PRESEED"
	echo "Writing installation instructions for [$CONFIG] in $SAVETO/$PRESEED"
	touch "$1/$PRESEED"

	cmd=($RTD_GUI --backtitle "$BRANDING" --title "VM Auto Answer Setup Questions" --separate-output --checklist "Please preconfiguration components below. You will be prompted to manually add information for sections that you de-select:" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" )
	options=(1 "rtd_oem_preseed_ubuntu_cfg_KS_CFG_Options" on
		 2 "rtd_oem_preseed_cfg_Unattended_Install" on
		 3 "rtd_oem_preseed_cfg_Network_Configuration" on
		 4 "rtd_oem_preseed_cfg_Prevent_Install_On_USB" on
		 5 "rtd_oem_cfg_Account_Setup" on
		 6 "rtd_oem_preseed_cfg_Localization" on
		 7 "rtd_oem_preseed_cfg_EFI" on
		 8 "rtd_oem_preseed_cfg_GRUB_Bootloader_Installation" on
		 9 "rtd_oem_preseed_cfg_Disk_Layout" on
		 10 "rtd_oem_preseed_cfg_Package_Selection" on
		 11 "rtd_oem_preseed_cfg_Addon_${SRVFUNC}" on
		)

		choices=$("${cmd[@]}" "${options[@]}" 2>&1 >/dev/tty)
		clear
		for choice in $choices
		do
			case $choice in
			1) rtd_oem_preseed_ubuntu_cfg_KS_CFG_Options "$SAVETO" ;;
			2) rtd_oem_preseed_cfg_Unattended_Install "$SAVETO" ;;
			3) rtd_oem_preseed_cfg_Network_Configuration "$SAVETO" ;;
			4) rtd_oem_preseed_cfg_Prevent_Install_On_USB "$SAVETO" ;;
			5) rtd_oem_cfg_Account_Setup "$SAVETO" ;;
			6) rtd_oem_preseed_cfg_Localization "$SAVETO" ;;
			7) rtd_oem_preseed_cfg_EFI "$SAVETO" ;;
			8) rtd_oem_preseed_cfg_GRUB_Bootloader_Installation "$SAVETO" ;;
			9) rtd_oem_preseed_cfg_Disk_Layout "$SAVETO" ;;
			10) rtd_oem_preseed_cfg_Package_Selection "$SAVETO" "$CONFIG" ;;
			11) rtd_oem_preseed_cfg_Addon_"${SRVFUNC}" "$SAVETO" ;;
			esac
		done
}


rtd_setup_choices_cli_workstation () {
	# Function to display legacy installation options. This will install software that is usefull
	# on a really old system, or a remote system only accessible via SSH. This may be a good
	# usecase if you happen to be in an opressed geographic locaiton where your only option is
	# to ssh to a remote server and access email and web that way. Perfomance in these cases
	# may be very poor over the internet (as for example with the great firewall of China). In
	# Such a case it would be usefull to have the good old CLI software! :)
	# List Options to be available for choice in the RTD System Configurator...
	cmd=($RTD_GUI --backtitle "$BRANDING" --title "Terminal Software add on Options Menu" --separate-output --checklist "You can be productive in the cli environment. Please Select Software titles below that you want to add to this system:" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" )
	options=(1 "Base RTD OEM Software (basic admin tools usually needed)" on
		 2 "Alpine email client" off
		 3 "Vim text editor" on
		 4 "Finch multi protocol chat" off
		 5 "Word Grinder word precessor" off
		 6 "Spreadsheet Calculator" off
		 7 "TPP Presentation Program" off
		 8 "Midnight Commander file manager (Norton Commander)" on
		 9 "Cmus Music Player" off
		 10 "Byobu Terminal Window Manger" off
		 11 "W3M web Browser" off
		 12 "LYNX Web Browser (Browse the web directly in the terminal)" off
		 13 "Mega.nz command line tools (Mega-CMD)" off
		 14 "Rtorrent torrent download software" off
		 15 "Install the OpenVpn client Software" off
		 16 "Games: Freesweep mine sweep game" off
		 17 "Games: Bastet Tetris Game" off
		)

		choices=$("${cmd[@]}" "${options[@]}" 2>&1 >/dev/tty)
		clear
		for choice in $choices
		do
			case $choice in
			1) for i in wine-stable ffmpeg netstat nmcli htop powertop iftop monit nethogs bmon darkstat ss mtr glances nmap iostat multitail ncdu multitail ; do InstallSoftwareFromRepo $i ; done ;;
			2) InstallSoftwareFromRepo alpine ;;
			3) InstallSoftwareFromRepo vim ;;
			4) InstallSoftwareFromRepo finch ;;
			5) InstallSoftwareFromRepo wordgrinder ;;
			6) InstallSoftwareFromRepo sc ;;
			7) InstallSoftwareFromRepo tpp ;;
			8) InstallSoftwareFromRepo mc ;;
			9) InstallSoftwareFromRepo cmus ;;
			10) InstallSoftwareFromRepo byobu ;;
			11) InstallSoftwareFromRepo w3m ;;
			12) InstallSoftwareFromRepo lynx ;;
			13) dl https://mega.nz/linux/MEGAsync/xUbuntu_19.04/amd64/ megacmd-*.deb ;;
			14) InstallSoftwareFromRepo rtorrent ;;
			15) InstallSoftwareFromRepo openvpn ;;
			16) InstallSoftwareFromRepo freesweep ;;
			17) InstallSoftwareFromRepo bastet ;;
			esac
		done
}


show_make_media_gui_server ()
{
	while true; do
		exec 3>&1
		selection=$($RTD_GUI \
		--backtitle "$BRANDING" --title "Create Automatic OS Install Media"  --menu "Please select which automatic operating system installation media to create.  (to Burn to CD, or trafer to a USB, or use with a VM):" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT"  \
		"1" "Automatic Install ISO for Ubuntu Server" \
		"2" "Automatic Install ISO for Ubuntu Graphical Server" \
		"3" "Automatic Install ISO for Debian Graphical Server" \
		"4" "Automatic Install ISO for Debian Minimal Server" \
		"5" "Automatic Install ISO for Minecraft Server (Latest)" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-

		case $exit_status in
			"$DIALOG_CANCEL") return	;;
			"$DIALOG_ESC") return ;;
		esac

		case $selection in
		0 )
			echo "Program terminated by user..."
		;;
		1 )
			rtd_oem_ubuntu_auto_install_iso_builder openssh-server server
			cleanup_and_finish
		;;
		2 )
			rtd_oem_ubuntu_auto_install_iso_builder xubuntu-core server
			cleanup_and_finish
		;;
		3 )
			prepare_environment_for_iso_creation
			download_and_manipulate_iso_debian debian lxde-desktop server
			create_iso_image_debian
			cleanup_and_finish
		;;
		4 )
			prepare_environment_for_iso_creation
			download_and_manipulate_iso_debian debian openssh-server server
			create_iso_image_debian
			cleanup_and_finish
		;;
		5 )
			prepare_environment_for_iso_creation
			download_and_manipulate_iso_debian debian openssh-server MinecraftServer
			create_iso_image_debian
			cleanup_and_finish
                ;;
		esac
	done
}



show_make_media_gui_desktop () {
	# List Options to be available for choice in the RTD System Configurator...
	while true; do
		exec 3>&1
		selection=$($RTD_GUI \
		--backtitle "$BRANDING" --title "Create Automatic OS Install Media"  --menu "Please select which automatic operating system installation media to create:" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT"  \
		"1" "Automatic Install Media for Ubuntu Standard Desktop (more MAC like)" \
		"2" "Automatic Install Media for Ubuntu with Plasma Desktop (more Windows like)" \
		"3" "Automatic Install Media for Ubuntu Gnome (without Ubuntu customization)" \
                "4" "Automatic Install Media for Ubuntu Minimal Standard desktop" \
		"5" "Automatic Install Media for Debian Default Desktop" \
		"6" "Automatic Install Media for Debian Light Weight Desktop" \
		"7" "Automatic Install Media for Debian Plasma Desktop" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-

		case $exit_status in
			"$DIALOG_CANCEL") return	;;
			"$DIALOG_ESC") return ;;
		esac

		case $selection in
		0 )
			echo "Program terminated by user..."
		;;
		1 )
			rtd_oem_ubuntu_auto_install_iso_builder ubuntu-desktop desktop
			cleanup_and_finish
		;;
		2 )
			rtd_oem_ubuntu_auto_install_iso_builder kubuntu-desktop server
			cleanup_and_finish
		;;
		3 )
			rtd_oem_ubuntu_auto_install_iso_builder ubuntu-gnome-desktop server
			cleanup_and_finish
		;;
                4 )
			rtd_oem_ubuntu_auto_install_iso_builder ubuntu-desktop-minimal desktop
			cleanup_and_finish
		;;
		5 )
			prepare_environment_for_iso_creation
			download_and_manipulate_iso_debian debian-desktop desktop
			create_iso_image_debian
			cleanup_and_finish
		;;
		6 )
			prepare_environment_for_iso_creation
			download_and_manipulate_iso_debian debian cinnamon-desktop
			create_iso_image_debian
			cleanup_and_finish
		;;
		7 )
			prepare_environment_for_iso_creation
			download_and_manipulate_iso_debian debian kde-desktop
			create_iso_image_debian
			cleanup_and_finish
		;;
		esac
	done
}



show_manage_vm_gui () {
	# List Options to be available for choice in the RTD System Configurator...
	while true; do
		exec 3>&1
		selection=$($RTD_GUI \
		--backtitle "$BRANDING" \
		--title "VM Managment Menu"  \
		--menu "Please select what you would like to do below:"  "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" \
		"1" "List all virtual machines on this system" \
		"2" "Backup all running virtual machines on this server" \
		"3" "Monitor VM's on this system "\
		"4" "Deploy a VM on this server" \
		2>&1 1>&3 )
		exit_status=$?
		exec 3>&-

		case $exit_status in
			"$DIALOG_CANCEL") return ;;
			"$DIALOG_ESC") return ;;
		esac

		case $selection in
		0 )
			echo "Program terminated by user..."
		;;
		1 )
			if hash virsh ; then
				result=$(virsh list --all )
				display_result "Virtual Machinces on this system:"
			else
				echo KVM Virtualization is not installed on this machine.
			fi
		;;
		2 )
			backup_running_vm
		;;
		3)
			echo "VM Status on This HOST: Press [Q] to quit."
			check_dependencies virt-top
			virt-top
		;;
		4 )
			while true; do
				exec 3>&1
				subselection2=$($RTD_GUI --backtitle "$BRANDING" --title "Make Virtual Machine" --menu "    "  $HEIGHT $WIDTH $LIST_HEIGHT \
				"1" "Make a SERVER VM (Minimal single purpose system)" \
				"2" "Make a VDI VM (chose desktop and distribution)" \
				2>&1 1>&3)
				exit_status=$?
				exec 3>&-

				case $exit_status in
					"$DIALOG_CANCEL") return	;;
					"$DIALOG_ESC") return ;;
				esac

				case $subselection2 in
					0) echo "Program terminated."
					;;
					1) show_deploy_server_VM_now_menu
					;;
					2) show_deploy_VDI_VM_now_menu
					;;
				esac
			done
		;;
		esac
	done
}


show_deploy_server_VM_now_menu ()
{

		while true; do
		exec 3>&1
		selection=$($RTD_GUI \
		--backtitle "$BRANDING" --title "Deploy VM Server"  --menu "Please select which type of VM to create:" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" \
		"1" "Ubuntu Server" \
		"2" "Ubuntu Graphical Server" \
		"3" "Debian Graphical Server" \
		"4" "Debian Minimal Server" \
                "5" "Minecraft Server" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-

		case $exit_status in
			"$DIALOG_CANCEL") return	;;
			"$DIALOG_ESC") return ;;
		esac

		case $selection in
		0 )
			clear
			echo "Program terminated by user..."
		;;
		1 )
			rtd_oem_ubuntu_auto_install_iso_builder ssh-server server
			make_kvm_virtual_machine_now_from_iso ubuntu19.10
			cleanup_and_finish
		;;
		2 )
			rtd_oem_ubuntu_auto_install_iso_builder xubuntu-core server
			make_kvm_virtual_machine_now_from_iso ubuntu19.10
			cleanup_and_finish
		;;
		3 )
			make_preseed_cfg "$( mktemp -d )" lxde-desktop
			make_kvm_virtual_machine_now_from_debian_org debian10
			cleanup_and_finish nomessage
		;;
		4 )
			make_preseed_cfg "$( mktemp -d )" openssh-server
			make_kvm_virtual_machine_now_from_debian_org debian10
			cleanup_and_finish nomessage
		;;
		5 )
			make_preseed_cfg "$( mktemp -d )" openssh-server MinecraftServer
			make_kvm_virtual_machine_now_from_debian_org debian10
			cleanup_and_finish nomessage
		;;
		esac

	done
}


show_deploy_VDI_VM_now_menu ()
{
	while true; do
		exec 3>&1
		selection=$($RTD_GUI --backtitle "$BRANDING" --title "Deploy Virtual Desktop (VDI)"  --menu "Please select which VDI to create on this server:" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" \
		"1" "Ubuntu Standard Desktop (more MAC like)" \
		"2" "Ubuntu with Plasma Desktop (more Windows like)" \
		"3" "Ubuntu Gnome (without Ubuntu customization)" \
                "4" "Ubuntu Minimal Standard desktop" \
		"5" "Debian Default Desktop" \
		"6" "Debian Cinnamon Desktop" \
		"7" "Debian Plasma Desktop" \
		"8" "Debian Light Weight Desktop (LXDE)" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-

		case $exit_status in
			"$DIALOG_CANCEL") return	;;
			"$DIALOG_ESC") return ;;
		esac

		case $selection in
		0 )
			clear
			echo "Program terminated by user..."
		;;
		1 )
			echo "***   Deploying a Ubuntu VDI with Gnome Desktop from ubuntu.com"
			make_preseed_cfg "$( mktemp -d )" ubuntu-desktop
			make_kvm_virtual_machine_now_from_ubuntu_com ubuntu20.04 
		;;
		2 )
			clear
			make_preseed_cfg "$( mktemp -d )" kubuntu-desktop
			make_kvm_virtual_machine_now_from_iso ubuntu20.04
		;;
		3 )
			clear
			make_preseed_cfg "$( mktemp -d )" ubuntu-gnome-desktop 
			make_kvm_virtual_machine_now_from_ubuntu_com ubuntu20.04
		;;
                4 )
			clear
			make_preseed_cfg "$( mktemp -d )" ubuntu-desktop-minimal 
			make_kvm_virtual_machine_now_from_ubuntu_com ubuntu20.04
		;;
		5 )
			clear
			make_preseed_cfg "$( mktemp -d )" gnome-desktop
			make_kvm_virtual_machine_now_from_debian_org debian10
			cleanup_and_finish nomessage
		;;
		6 )
			clear
			make_preseed_cfg "$( mktemp -d )" cinnamon-desktop
			make_kvm_virtual_machine_now_from_debian_org debian10
			cleanup_and_finish nomessage
		;;
		7 )
			clear
			make_preseed_cfg "$( mktemp -d )" kde-desktop
			make_kvm_virtual_machine_now_from_debian_org debian10
			cleanup_and_finish nomessage
		;;
		8 )
			clear
			make_preseed_cfg "$( mktemp -d )" lxde-desktop
			make_kvm_virtual_machine_now_from_debian_org debian10
			cleanup_and_finish nomessage
		;;
		esac

	done
}


show_view_informaion_about_this_system () {
	while true; do
		exec 3>&1
		selection=$($RTD_GUI --backtitle "$BRANDING" --title "System Information Menu" --menu "" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" \
		"1" "Show system summary" \
		"2" "Show storage device space utilization" \
		"3" "Show users HOME folder storage use" \
		"4" "Show complete storage utilization by directory" \
		"5" "Show system temperature information" \
		"6" "Show detailed system CPU information" \
		"7" "Show systems physical location (city, county etc.)" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-

		case $exit_status in
			"$DIALOG_CANCEL") return	;;
			"$DIALOG_ESC") return ;;
		esac

		case $selection in
		0 )
			clear
			echo "Program terminated by user..."
		;;
		1 )
			clear
			check_dependencies neofetch
			clear
			neofetch --memory_display barinfo
			ip -br addr
			read -p "Press [Enter] key to return to the main menu: "
		;;
		2 )
			clear
			echo "Please wait while I calculate disk space... "
			result=$(df -h -x squashfs -x tmpfs)
			$RTD_GUI --backtitle "$BRANDING" --title "System Storage Space" --msgbox "$result" 20 100
		;;
		3 )
			clear
			generate_report_disk_space_used_by_directory /home
			display_result "Home Space Utilization (All Users)"
		;;
		4 )
			clear
			generate_report_disk_space_used_by_directory /
			display_result "Total Space Utilization root directory:"
		;;
		5 )
			check_dependencies lm-sensors
			sudo /etc/init.d/kmod start
			check_dependencies hddtemp
			sudo sensors-detect --auto
			clear
			result=$( sensors )
			display_result "System Temperature Information"
		;;
		6 )
			clear
			result=$(lscpu)
			display_result "System CPU Information"
		;;
		7 )
			clear
			check_dependencies curl &>/dev/null
			check_dependencies dnsutils &>/dev/null
			result=$(curl ipinfo.io/$(dig +short myip.opendns.com @resolver1.opendns.com))
			display_result "This systems location on the Internet"
		;;
		esac
	done
}


show_manage_software_gui () {
	# List Options to be available for choice in the RTD System Configurator...
	while true; do
		exec 3>&1
		selection=$($RTD_GUI \
		--backtitle "$BRANDING" --title "Software Managment Menu"  --menu "" $HEIGHT $WIDTH $LIST_HEIGHT \
		"1" "Update all software on this system" \
		"2" "Show what Personal Package Archives (PPA's) are defined on this system" \
		"3" "Remove all Personal Package Archives (PPA's) NOT in use on this system" \
		"4" "Attempt a full release upgrade " \
		"5" "Install Non-GUI productivity tools for a useful terminal based workstation" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-

		case $exit_status in
			$DIALOG_CANCEL) return	;;
			$DIALOG_ESC) return ;;
		esac

		case $selection in
		0 )
			exit_status=$?
		;;
		1 )
			clear
			rtd_update_system ; rtd_oem_pause 1
		;;
		2 )
			clear ; dist_info="$(hostnamectl)"
			if echo $dist_info |grep ".*buntu" &>/dev/null ; then
				result="$(rtd_ppa_checker)"
				display_result "Packages Installed from Personal Package Archives"
			elif echo $dist_info |grep "Pop!_OS" 2>/dev/null ; then
				result="$(rtd_ppa_checker)"
				display_result "Packages Installed from Personal Package Archives"
			else
				result="Non Ubuntu based distributions do not Support the use of Personal Package Archives \n Press [ OK ] to return to the prevous menu."
				display_result "Functionality Not Supported"
			fi
		;;
		3 )
			clear ; dist_info="$(hostnamectl)"
			if echo $dist_info |grep ".*buntu" &>/dev/null ; then
				rtd_ppa_checker --delete | $RTD_GUI --programbox "Personal Package Archive Check:" $HEIGHT $WIDTH
			elif echo $dist_info |grep "Pop!_OS" 2>/dev/null ; then
				rtd_ppa_checker --delete | $RTD_GUI --programbox "Personal Package Archive Check:" $HEIGHT $WIDTH
			else
				result="Non Ubuntu based distributions do not Support the use of Personal Package Archives \n Press [ OK ] to return to the prevous menu."
				display_result "Functionality Not Supported"
			fi
		;;
		4 )
			rtd_oem_release_upgrade
		;;
		5 )
			rtd_setup_choices_cli_workstation
		;;
		esac
	done
}


show_main_menu () {
	while true; do
		exec 3>&1
		selection=$( $RTD_GUI --backtitle "$BRANDING" --cancel-button "EXIT" --title "RTD Tool Main Menu" --menu "" $HEIGHT $WIDTH $LIST_HEIGHT \
			"1" "View information about this system" \
			"2" "Manage Software on this system" \
			"3" "Manage Virtual Machines (KVM) on this system" \
			"4" "Manage encryption phrases and passwords" \
			"5" "Make media to automatically install OS (for VM's and CD burning)" \
			"6" "Shortcut: Update this system now"\
			2>&1 1>&3)
		exit_status=$?
		exec 3>&-

		case $exit_status in
			$DIALOG_CANCEL)
				clear
				echo "Program terminated."
				exit 0
			;;
			$DIALOG_ESC)
				clear
				echo "Program aborted." >&2
				exit 0
			;;
		esac

		case $selection in
			0 )
				clear
				echo "Program terminated."
			;;
			1 )	show_view_informaion_about_this_system
			;;
			2 )	show_manage_software_gui
			;;
			3 )	show_manage_vm_gui
			;;
			4 )	show_manage_crypt_sec
			;;
			5 )
			while true; do
				exec 3>&1
					subselection1=$($RTD_GUI --backtitle "$BRANDING" --title "Create Automatic OS Install Media" --menu "Please select if you need to make media for a server or a desktop. You will be aksed if you you want to transfer the media to a DC/DVD/USB Stick or deploy directly as a VM"  $HEIGHT $WIDTH $LIST_HEIGHT \
					"1" "Make media to build a server (ISO or USB Disk)" \
					"2" "Make media to build a Desktop environment (ISO or USB Disk)" \
					2>&1 1>&3)
				exit_status=$?
				exec 3>&-

				case $exit_status in
					$DIALOG_CANCEL) return ;;
					$DIALOG_ESC) return ;;
				esac
	
				case $subselection1 in
					0 ) echo "Program terminated."
					;;
					1 ) show_make_media_gui_server
					;;
					2 ) show_make_media_gui_desktop
					;;
				esac
			done
			;;
			6 )	
				rtd_update_system
				read -p "Press [Enter] key to return to the main menu: "
			;;
		esac
	done
}


show_manage_crypt_sec () {
	while true; do
		exec 3>&1
		selection=$($RTD_GUI \
			--backtitle "$BRANDING" \
			--title "Manage encryption phrases and passwords" \
			--menu "" $HEIGHT $WIDTH $LIST_HEIGHT \
			"1" "Check if a password is stolen" \
			"2" "Change systems disk encrytion pass phrase" \
			"3" "Change "$SUDO_USER" password" \
			2>&1 1>&3)
		exit_status=$?
		exec 3>&-

		case $exit_status in
			$DIALOG_CANCEL) return ;;
			$DIALOG_ESC) return ;;
		esac

		case $selection in
			0 )
				clear
				echo "Program terminated."
			;;
			1 )
				check_if_password_p0wned
			;;
			2 )
				change_disk_pass
			;;
			3 )
				passwd $SUDO_USER
			;;
		esac
	done
}




#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::          Script templates                ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# Useful code sniplet templates. Copy and paste these and the edit them
# as necessary to extend the functoinality of this tool.
#




menu_template () {
	while true; do
		exec 3>&1
		# Dialog Display Menu Items...
			selection=$($RTD_GUI \
				--backtitle "$BRANDING" \
				--title "Menu Title" \
				--menu "Please tell me what I can do for you:" $HEIGHT $WIDTH $LIST_HEIGHT \
				"1" "Description" \
				"2" "Description" \
				"3" "Description" \
				2>&1 1>&3)
			exit_status=$?
			exec 3>&-

		# Cases for how program exited...
		case $exit_status in
			$DIALOG_CANCEL)
				clear
				echo "Program terminated."
				exit
			;;
			$DIALOG_ESC)
				clear
				echo "Program aborted." >&2
				exit 1
			;;
		esac

		# What to do depending on selection...
		case $selection in
			0 )
				clear
				echo "Program terminated."
			;;
			1 )
				# code
			;;
			2 )
				# code
			;;
			3 )
				# code
			;;
		esac
	done
}











#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::          Script Main Init                ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# Below is the logic for starting this script. As this script pretty much exclusively uses
# functions and function calls for everything it is simple to control the flow of execution here.
# We must ensure that the script is run at the proper privileges and in a
# re-attachable session. This means that this script will not allow itself to be run in
# a root terminal or using the sudo command. The reason for this is that, in order to start in
# a detachable terminal session "byobu", it may not be launched by root. The script will
# need to be run as a normal administrative user with access to "sudo" a.k.a. a member of the
# "sudoers" security group. This helps adhere to the best practice of NOT using a root interactive
# terminal.

if [[ -z "$BASH_VERSINFO" ]]; then
	echo "ERROR: You must execute this script in a BASH Shell" >&2
	exit 255
fi




if [[ "$TERM" == screen* ]]; then
	ensure_admin "$@"			# Do we have admin priviledges?
	rtd_oem_check_inet_access		# Confirm what to do if no internet access.
	check_menu_availability			# Can we display menus and ask questions?
	show_notice_on_fist_run			# Is this the first time this is used on this computer?
	rtd_oem_ensure_rtd_library_available	# If the required system managment library available?
	show_main_menu				# If all is OK, display the system admin menu!

else
	if hash byobu 2>/dev/null; then
		byobu new-session -s "RTD Simple Server Support Tools" "$0 $*"
		#clear
	else
		check_dependencies byobu && echo -e "$RED" "A critical component needed for this script to work properly was attempted to be added... Attempting to run the script again!" "$ENDCOLOR"
		su -c "$0 $*" "$SUDO_USER"
		clear
	fi
fi

