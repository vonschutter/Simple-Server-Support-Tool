#!/bin/bash
#::				S I M P L E     S Y S T E M   S U P P O R T    T O O L 
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#:: Author(s):   	SLS, KLS, NB.  Buffalo Center, IA & Avarua, Cook Islands
    RTD_Version=1.06
#::
#::
#::	Purpose: To simplify support tasks 
#::		  - Display system information 
#::		  - Update system software
#:: 		  - Bakup virtual machines 
#::               - Cleanup/Report on PPA's
#::               - Show systems physical location 
#::		  - Check if a password you intend to use is for sale on the Darknet
#::
#::     Usage: run the script "bash /path/to/rtd" or if installed in the $PATH; by rtd simply type "rtd" in a terminal.
#:: 
#::     This script is shared in the hopes that
#::     someone will find it usefull.
#::
#::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#	
#	NOTE:	This terminal program is written to be readable and documented to a very high degree. The reason is that
#		these apps are seldom changed and when they are, it is usefull to be able to understand why and how 
#		things were built. Obviously, this becomes a useful learning tool as well; for all people that want to 
#		learn how to write admin scripts. It is a good and necessary practice to document extensively and follow
#		patterns when building your own apps and config scripts. Failing to do so will result in a costly mess
#		for any organization after some years and people turnover. 
#
#		As a general rule, we prefer using functions extensively because this makes it easier to manage the script
#		and facilitates several users working on the same scripts over time.
#		
# 
#	RTD admin scrips are placed in /opt/rtd/scripts. Optionally scripts may use the common
#	functions in _rtd_functions and _rtd_recipies: 
#
#	  _rtd_functions -- contain usefull admin functions for scripts, such as "how to install software" on different systems. 
#	  _rtd_recipies  -- contain software installation and configuration "recipies". 
#
#	Scripts may also be stand-alone if there is a reason for this. This script is written to function independently 
#	so that it is easy to copy to many server systems, or just to use once on a remote system. This is accomplished by
#	including all functions and dependency checking in this script; as well as avoidnig relying on external files like 
#	*.diff files. As a consequence of the portability benefit this script becomes rather large and time consuming to navigate. 
#
#	Taxonomy of this script: we prioritize the use of functions over monolithic script writing, and proper indentation
#	to make the script more readable. Each function shall also be documented to the point of the obvious.
#	Suggested function structure per google guidelines:
#
#	function_descriptive_name () {
#		# Documentation and comments... 
#		...code...
#	}
#
#	We also like to log all activity, and to echo status output to the screen in a frienly way. To accomplish this,
#	the table below may be used as appropriate: 
#
#				OUTPUT REDIRECTION TABLE	
#
#		  || visible in terminal ||   visible in file   || existing
#	  Syntax  ||  StdOut  |  StdErr  ||  StdOut  |  StdErr  ||   file   
#	==========++==========+==========++==========+==========++===========
#	    >     ||    no    |   yes    ||   yes    |    no    || overwrite
#	    >>    ||    no    |   yes    ||   yes    |    no    ||  append
#	          ||          |          ||          |          ||
#	   2>     ||   yes    |    no    ||    no    |   yes    || overwrite
#	   2>>    ||   yes    |    no    ||    no    |   yes    ||  append
#	          ||          |          ||          |          ||
#	   &>     ||    no    |    no    ||   yes    |   yes    || overwrite
#	   &>>    ||    no    |    no    ||   yes    |   yes    ||  append
#	          ||          |          ||          |          ||
#	 | tee    ||   yes    |   yes    ||   yes    |    no    || overwrite
#	 | tee -a ||   yes    |   yes    ||   yes    |    no    ||  append
#	          ||          |          ||          |          ||
#	 n.e. (*) ||   yes    |   yes    ||    no    |   yes    || overwrite
#	 n.e. (*) ||   yes    |   yes    ||    no    |   yes    ||  append
#	          ||          |          ||          |          ||
#	|& tee    ||   yes    |   yes    ||   yes    |   yes    || overwrite
#	|& tee -a ||   yes    |   yes    ||   yes    |   yes    ||  append
#
#	Our scripts are also structured in to three major sections: "settings", "functions", and "execute". 
#	Settings, contain configurable options for the script. Functions, contain all functions. Execute, 
#	contains all the actual logic and control of the script. 
#
#
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::





#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::            Script Settings               ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# You may comment out or edit items as you deem necessary.
# Some formatting options for cli graphic display.
BRANDING="RunTime Data : Simple Server Support Tool"
DIALOG_CANCEL=1
DIALOG_ESC=255
HEIGHT=20
WIDTH=80
LIST_HEIGHT=12

# Set location to backup virtual machines to. This location must have addequate space
# to store several copies of the virtual machine disks. This may be a network share or
# an external storage or san mount point. 
VM_BACKUP_TARGET="/mnt/vmdsk/VM_BACKUP"

# Terminal Color Setup definitions. These settings allow the simlified use of
# text colors in the teminal. You may want to echo RED for error or GREEN for OK. 
YELLOW="\033[1;33m"
RED="\033[1;31m"
ENDCOLOR="\033[0m"
GREEN="\033[1;32m"
BLUE="\033[1;34m"

# Set the background color of the tool. The appearance of the manu system may 
# look different on different systems depending on their default settings. 
# Here we define the bacground color for consistency. 
export NEWT_COLORS='root=,blue '	

# Details for the ISO image creator. To change from one Ubuntu release to another you 
# may change the "RELEASE" option. If you wold like to use the ISO maker to build a custom 
# Debian installer you may change the "SOURCE_ISO_URL" option to poit to the Debian location. 
# Finally, should you desire using your own preseed template (answers to the install questions)
# you should change the "PRESEED_TEMPLATE" option to point to the location of you own template. 
RELEASE=disco
TARGET_ISO_FILE_NAME="$RELEASE-netinstall-auto.iso"
SOURCE_ISO_URL="http://archive.ubuntu.com/ubuntu/dists/$RELEASE/main/installer-amd64/current/images/netboot/mini.iso"
SSH_PUBLIC_KEY_FILE="$HOME/.ssh/id_rsa.pub"
PUT_ISO_FILE_HERE_WHEN_DONE="$HOME"
VOLUME_TITLE="RTD Ubuntu Auto Installer"
PRESEED_TEMPLATE="https://github.com/vonschutter/Blind_Install/raw/master/custom/preseed.template"

# Set location to where to log information: 
# in the system log directory in a file named the same as this script.
LOGFILE="/var/log/${0##*/}.log"








#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::            Tool Executive Functions      ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# 
# Below please find the executive functions of this script. These re the functions 
# that actually do the work requested. 
#
#



ensure_admin () {
        # Function to ensure administrative privileges such that system wide settings 
        # or configuration may be done. This function will make the script call itself 
        # with sudo if the user ID is not 0 e.g. root.
        [ "$UID" -eq 0 ] || echo -e $YELLOW "The $BLUE $BRANDING $YELLOW needs administrative access..." $ENDCOLOR
        [ "$UID" -eq 0 ] || exec sudo bash "$0" "$@"
    }



check_if_password_p0wned () {
	pass_str=$(whiptail --passwordbox "Please enter your intended password to validate your new password against P0wned DB" 8 78 --title "" 3>&1 1>&2 2>&3)
	result=$( 
		sha1=$(echo -n $pass_str | tr -d '\n' | sha1sum); echo "Hash prefix: ${sha1:0:5}"; echo "Hash suffix: ${sha1:5:35}"; 
		query_result=$(curl https://api.pwnedpasswords.com/range/${sha1:0:5} 2>/dev/null | grep $(echo ${sha1:5:35} | tr '[:lower:]' '[:upper:]')); 
		printf "Your password appeared %d times for sale in the Darknet per the P0wned online database...." "${query_result#*:}" 2>/dev/null ;
		unset pass_str ;
		)
	display_result "Password P0wned Status"
}




prepare_environment_for_iso_creation () {
	# Facilitate showing collorfull statements in terminal... 
	set_colors
	#Include the path to where the isofile will be put... 
	: "${TARGET_ISO="$PUT_ISO_FILE_HERE_WHEN_DONE/$TARGET_ISO_FILE_NAME"}"
	# Ensure that all needed software, outside of the most rudimantary, 
	# is available to us... If not, the script should exit. 
	: "${_DEPENDENCIES="dos2unix cpio gzip genisoimage whois pwgen wget fakeroot xorriso"}"
	#set -e
	for i in $_DEPENDENCIES 
	do 
		check_dependencies $i
	done

	# Find full paths for the binaries needed since if they are recently 
	# added, they may not be found in the current $PATH. These statements will be evaluated
	# when the variables are referenced not here because of the ":". FYI...
	: "${BIN_7Z:=$(type -P 7z)}"
	: "${BIN_XORRISO:=$(type -P xorriso)}"
	: "${BIN_CPIO:=$(type -P gnucpio || type -P cpio)}"
	: "${ISOHDPFX_BIN:=$(locate isohdpfx.bin  | head -n 1)}"
	: "${PRESEED_TEMPLATE:="https://github.com/vonschutter/Blind_Install/raw/master/custom/preseed.template"}"
	: "${SSH_PUBLIC_KEY_FILE:="/home/$SUDO_USER/.ssh/id_rsa.pub"}"

	# Find the location of the public key on this machine...
	# This should be updated to create a key if not there... 
	if [ ! -f "$SSH_PUBLIC_KEY_FILE" ];
	then
		echo "Error: public SSH key $SSH_PUBLIC_KEY_FILE not found!"
		# exit 1
	fi

	# Setup the required folder structure... 
	CURRENT_DIR="`pwd`"
	SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
	TMP_DOWNLOAD_DIR="`mktemp -d`"
	TMP_DISC_DIR="`mktemp -d`"
	TMP_INITRD_DIR="`mktemp -d`"

	# Load the installation answers template.
	echo -e $YELLOW Geting intall instructions template... $ENDCOLOR
	mkdir -p $SCRIPT_DIR/custom
	wget $PRESEED_TEMPLATE -P $SCRIPT_DIR/custom
}




download_and_manipulate_iso () {
	# This is a simple command sequence to read the preference of distribution to install
	# and what release to get... then download the network install file from ubuntu
	# and manipulate the iso file to complete the edited instruction in the preseed.cfg... 
	RELEASE=$1
	PREFERENCE=$2
	TARGET_ISO=$PUT_ISO_FILE_HERE_WHEN_DONE/$PREFERENCE-$TARGET_ISO_FILE_NAME
	cd "$TMP_DOWNLOAD_DIR"
	wget -4 "$SOURCE_ISO_URL" -O "./netboot.iso"
	"$BIN_7Z" x "./netboot.iso" "-o$TMP_DISC_DIR"
	cd "$TMP_DISC_DIR"


# ------------------- Patch 1 grub .cfg ------------------------ #
$YELLOW
patch ./boot/grub/grub.cfg <<PATCH
11a12
> set timeout=10
13c14
< menuentry "Install" {
---
> menuentry "Automatic Install" {
PATCH
$ENDCOLOR
# -------------------------------------------------------------- #


# ---------------------Patch 2 isolinux.cfg -------------------- #
$YELLOW
dos2unix "./isolinux.cfg"
patch ./isolinux.cfg <<PATCH_II
7c7
< timeout 0
---
> timeout 100
PATCH_II
$ENDCOLOR
# -------------------------------------------------------------- #


	cat "$SCRIPT_DIR/custom/preseed.template" > "$SCRIPT_DIR/custom/preseed.cfg"
	sed -i s/oem-replace-me-desktop-selection/$PREFERENCE/g "$SCRIPT_DIR/custom/preseed.cfg"
	cd "$TMP_INITRD_DIR"
	mkdir ./custom
	cp "$SCRIPT_DIR/custom/preseed.cfg" "./preseed.cfg"
	cp "$SSH_PUBLIC_KEY_FILE" "./custom/userkey.pub"

# ---------------------Create ssh key service ------------------ #
cat << SSH_KEY_KEYGEN > ./custom/ssh-host-keygen.service
[Unit]
Description=OpenSSH Server Key Generation
Before=ssh.service

[Service]
ExecStart=/usr/bin/ssh-keygen -A
Type=oneshot
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
SSH_KEY_KEYGEN
# -------------------------------------------------------------- #

	cat "$TMP_DISC_DIR/initrd.gz" | gzip -d > "./initrd"
	echo "./preseed.cfg" | fakeroot "$BIN_CPIO" -o -H newc -A -F "./initrd"
	find "./custom" | fakeroot "$BIN_CPIO" -o -H newc -A -F "./initrd"
	cat "./initrd" | gzip -9c > "$TMP_DISC_DIR/initrd.gz"

}



create_iso_image (){
    # Delete old iso file if there... 
    if [ -f "$TARGET_ISO" ]; then
            rm -f "$TARGET_ISO"
    fi

    cd "$TMP_DISC_DIR"
    rm -r '[BOOT]'
    "$BIN_XORRISO" -as mkisofs -r -V "$VOLUME_TITLE" -J -b isolinux.bin -c boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table -input-charset utf-8 -isohybrid-mbr "$ISOHDPFX_BIN" -eltorito-alt-boot -e boot/grub/efi.img -no-emul-boot -isohybrid-gpt-basdat -o "$TARGET_ISO" ./
    chmod 777 "$TARGET_ISO"
}



make_qcow2 () {
	# Function to create a KVM virtual michine disk and define a VM. This function should be
	# used on a Qemu/KVM virtual host that the virtual guest is to be used on. 
	# NOTE: QCOW2 is a storage format for virtual . 
	# machine disk images QCOW stands for QEMU copy on write. The QCOW2 format decouples the physical storage 
	# layer from the virtual layer by adding a mapping between logical and physical blocks. 
	# NOTE2: Kernel-based Virtual Machine (KVM) is an open source virtualization technology built into Linux®. 
	# Specifically, KVM lets you turn Linux into a hypervisor that allows a host machine to run multiple, 
	# isolated virtual environments called guests or virtual machines (VMs). KVM is part of Linux.
	# For complete info: https://www.redhat.com/en/topics/virtualization/what-is-KVM
	# set -e
	# Use the check_dependencies function to make sure the needed software is available.
	check_dependencies qemu-img
	check_dependencies kvm
	# Lookup specific binaries: use full path since they may just have been added and not in $PATH yet.
	: "${BIN_QEMU_IMG:=$(type -P qemu-img)}"
	: "${BIN_KVM:=$(type -P kvm)}"

	# Get parameters if provided, otherwise use defaults. 
	RAM_SIZE=${1:-"1024"}
	DISK_SIZE=${2:-"10G"}
	DISK_FORMAT=${3:-"qcow2"}
	DISK_FILE=${5:-"`pwd`/TARGET_ISO_FILE_NAME-$RAM_SIZE-$DISK_SIZE.$DISK_FORMAT"}

	# Verify ISO presesnce
		if [ -f "$TARGET_ISO" ]; then
			whiptail --backtitle "$BRANDING" --title "NOTICE!" --msgbox "OOOPS! You did a booboo... you have to first choose to create an ISO in the menu" 10 60
			clear
			exit
		fi

	# create image and run installer
	"$BIN_QEMU_IMG" create "$DISK_FILE" -f "$DISK_FORMAT" "$DISK_SIZE"
	"$BIN_KVM" -m "$RAM_SIZE" -cdrom "$TARGET_ISO" -boot once=d "$DISK_FILE"

	# remove tmp
	rm -r -f "$TMP_ISO_DIR"
}




set_install_command () {
	# add global install command for portability and convenience
	# If you need to use this script in an rpm based system you could modify the install
	# command here to suit dnf, yum, zypper... By default packages of patternd that do not
	# match should be skipped. Use "export option" so child processes also see the variiables.
	if [[ "$OSTYPE" == "linux-gnu" ]]; then
		if hash pkcon 2>/dev/null; then
			# If package kit is available then prefer this
			echo -e $YELLOW "Setting install options for Package Kit" $ENDCOLOR	 
			export _INSTCMD="pkcon -y  install"
		elif hash yum 2>/dev/null; then
			# If package kit is not available try yum (RedHat, Cent OS, Fedora)
			echo -e $YELLOW "Setting install options for YUM" $ENDCOLOR
			export _INSTCMD="yum -y  install"
		elif hash apt 2>/dev/null; then
			# If package kit is not available try apt (Debian, Ubuntu, and all derivatives)
			echo -e $YELLOW "Setting install options for DEB" $ENDCOLOR	        
			export _INSTCMD="apt-get -y -qq --allow-change-held-packages --ignore-missing install"
			export DEBIAN_FRONTEND=noninteractive
		elif hash zypper 2>/dev/null; then
			# If package kit is not available try zypper (Open SUSE)
			echo -e $YELLOW "Setting install options for ZYPPER" $ENDCOLOR
			export _INSTCMD="zypper install -y "
		else
			echo -e $YELLOW "This system does not seem to have a software managment system" $ENDCOLOR
			exit 1
		fi

	elif [[ "$OSTYPE" == "freebsd"* ]]; then
		echo "Free BSD is currently unsupported... "
		export _INSTCMD="echo I dont know how to install suff on FreeBSD!"
	else
	echo "I have no Idea what this system is"
		export _INSTCMD="echo Whatever!"
		exit 1
	fi
}



is_software_package_installed () {
	# Function to check if a piece of software is installed. This function will first check
	# if the package manager is deb, zypper or rpm, and then take one parameter passed
	# and evauate if a software package by that name is installed. This function
	# will return a "0" or "1" return based on the package managers return code.
	# Call this function by: 
	# is_software_package_installed "package name" 
	#                 or 
	# is_software_package_installed "$1" if calling this function from a script
	# or another function receiving a parameter.
	#
	if hash yum 2>/dev/null; then
		rpm -q "$1" > /dev/null 2>&1 && return 0 || return 1
	elif hash apt 2>/dev/null; then
		dpkg -l "$1" 2>/dev/null |tail -1 |grep "ii  $1" > /dev/null 2>&1 && return 0 || return 1
	elif hash zypper 2>/dev/null; then
		zypper se "$1" > /dev/null 2>&1 && return 0 || return 1
	else
		return 3
	fi
}



is_software_package_available () {
	# Function to chek if a package is available in whetever repository, and 
	# if there return a "0" and if not return a "1" or a "3" if there is no recognizable 
	# package manager found. The function expects the name of the package 
	# to be a parameter passed to this fuction. Call this function by: 
	# is_software_package_available "package name" 
	#                 or 
	# is_software_package_available "$1" if calling this function from a script
	# or another function receiving a parameter.
	#
	# Supported base distributions: Fedora . SuSE . Debian
	if hash yum 2>/dev/null; then
		yum list available "$1" &> /dev/null && return 0 || return 1
	elif hash apt 2>/dev/null; then
		apt -qq list "$1" 2>/dev/null | grep -q "$1" && return 0 || return 1
	elif hash zypper 2>/dev/null; then
		return zypper info "$1" &> /dev/null && return 0 || return 1
	else
		return 3
	fi

	}



InstallSoftwareFromRepo () {
	# Function to simplify the installation of software by including all display and 
	# installation logic for a given software provider. This should be expanded to include flatpack
	# snap for example. It should be the same consistent way no matter flavor of Linux. 
	# This function uses the "$_INSTCMD" to install software. "$_INSTCMD" is defined separatley and could 
	# be an RPM or deb string, or even snap or flatpack. A preference order between package system and
	# snap or flatpack use.     

	# make some decent display terminal Graphics...
	# This function uses set_install_command and ensure_admin to be able to, and know how to, install a package...
	#
	set_install_command
	ensure_admin
	PAD="--------------------------------------------------"
	LINE=$(printf "%s %s" "$@" "$PAD" | cut -c 1-${#PAD})
	# Test if package name is installed, if not then...
	if ! is_software_package_installed "$@"; then
		if is_software_package_available   "$@"; then
		echo -ne "--- Installing "$LINE" ":" "\ & $_INSTCMD "$@" >>$LOGFILE.log 2>&1 && printf "%b%-6s%b [ \xE2\x9C\x94 ] $GREEN OK!$ENDCOLOR   \n" ||printf "%b%-6s%b [ ! ] $RED FAILED $ENDCOLOR  \n"
		else
		echo -ne "--- Installing "$LINE" ":" "\ && printf "%b%-6s%b [ \xE2\x9C\x94 ] $YELLOW Not available $ENDCOLOR \n"
		fi
	else
		echo -ne "--- Installing "$LINE" ":" "\ && printf "%b%-6s%b [ \xE2\x9C\x94 ] $YELLOW Already installed $ENDCOLOR \n"
	fi

}

 

check_dependencies () {
    # Function to check that a piece of software is installed and if not install it.
    # Works for apt, yum, and rpm based systems currently as long as the package name is the same. 
    # The function will take a parameter that is expected to match the software command line name 
    # or rather the name of the package. This function now relies on the return value of
    # the function "is_software_package_installed" as it is a more reliable way to see if a package of
    # software is installed according to the package manamgent system rather than the "hash" function
    # that checks if a command is available, since command name and package name are not allways the same...

	#---------------------------------------------------------------
        echo "Validating dependencies and installing them if not there..."
	#---------------------------------------------------------------
        if is_software_package_installed $1 ; then
		echo -e "$YELLOW $1 $ENDCOLOR is present on this system..."
        else
                echo -e "$YELLOW $1 $ENDCOLOR not found: I will try to get it... " 
                InstallSoftwareFromRepo $1
                if [ $? != 0 ];
                then
                        echo -e $RED "That install didn't work out so well!" 
                        echo -e "Please manually try to add the software since I couldn't do it." $ENDCOLOR
                        exit 1
                fi
        echo "OK Done! Continuing..."
        fi
}




rtd_update_system () {
        PUBLICATION="RuntimeData Update Manager for Linux"
        VERSION="1.13 (built in)"
        # System update function. The purpose of this function is to update installed software from 
	# distribution reopositories and the newer self contained universal software stores like 
        # snap and flatpak. 
	LOGFILE="${LOGFILE:=$0}"
	

        echo -e $GREEN"$PUBLICATION: Version $VERSION" $ENDCOLOR
        echo -e $GREEN"------------------------------------------------" $ENDCOLOR

        echo I am updating software from all channels i can find on the system. 
        echo I will update via the native package manager as well as newer formats
        echo -e "like $YELLOW"snap"$ENDCOLOR and $YELLOW"flatpak"$ENDCOLOR..."
        echo " " 


        log_item ()
        {
                DATE=$(date '+%d/%m/%Y %H:%M:%S');
                echo "$DATE --- : $@" >> $LOGFILE
        }

        deb_software_task ()
        {
                log_item "running deb_software_task with parameters $@"
                # make some decent display terminal graphics...
                PAD="------------------------------------------"
                LINE=$(printf "%s %s" "$@" "$PAD" | cut -c 1-${#PAD})
                echo -ne "--- Executing "$LINE"":""\ & $@ >>$LOGFILE 2>&1 && printf "%b%-6s%b [ \xE2\x9C\x94 ] $GREEN OK!$ENDCOLOR   \n" ||printf "%b%-6s%b [ ! ] $RED FAILED $ENDCOLOR  \n"
        }
        # Update native software packages; since it is not known what distribution 
	# this script is being executed on, it is best to check and see if we are able 
	# to perform an update and then do the update... 
	# One could choose to check for a supported exact version: e.g. Ubuntu, but we would 
	# like to be nice and add value for as many as we can. Specially if it is this easy! :) 
	if hash pkcon 2>/dev/null; then
		# If package kit is available then prefer this
		echo -e $YELLOW "Setting install options for Package Kit" $ENDCOLOR
		pkcon -y update 2>> $LOGFILE
		#| whiptail --gauge "Updating native packages..." 6 50 0
	elif hash yum 2>/dev/null; then
		# If package kit is not available try yum (RedHat, Cent OS, Fedora)
		echo -e $YELLOW "Setting install options for YUM" $ENDCOLOR
		deb_software_task yum -y upgrade 2>> $LOGFILE
	elif hash apt 2>/dev/null; then
		# If package kit is not available try apt (Debian, Ubuntu, and all derivatives)
		echo -e $YELLOW "Setting install options for DEB" $ENDCOLOR
		deb_software_task apt-get update    
		deb_software_task apt-get upgrade -y
		deb_software_task apt-get autoremove -y
	elif hash zypper 2>/dev/null; then
		# If package kit is not available try zypper (Open SUSE)
		echo -e $YELLOW "Setting install options for ZYPPER" $ENDCOLOR
		deb_software_task zypper up -y 2>> $LOGFILE
	else
		echo -e $YELLOW "This system does not seem to have a software managment system" $ENDCOLOR
		exit 1
	fi

        # updating snaps if snap is present on the system... 
        if hash snap 2>/dev/null; then
                snap refresh 2>> $LOGFILE
		#| whiptail --gauge "Updating snap packages..." 6 50 0
        else 
                echo "--- snap software is not present on this system... skipping..."
        fi

        # updating flatpacks if flatpack is present on system... 	
        if hash flatpak 2>/dev/null; then
                flatpak update -y 2>> $LOGFILE
		#| whiptail --gauge "Updating flapak packages..." 6 50 0
        else 
                echo "--- flatpak software is not present on this system... skipping..."
        fi
}



backup_running_vm () {
	# Function to back up all funning virtual machines on the host it is being run on. 
	# This function should be called from within this script and down not require any 
	# parameters passed. 
	clear
	ensure_admin
	if hash virsh ; then 
		echo Virtual Machinces on this system: 
		echo " "
		virsh list --all 
	else
		echo KVM Virtualization is not installed on this machine.
	fi

	# To exclude a VM (domain), add "nobackup" to its name and it will be ignored.
	# To rename: shutdown the guest, then use this command: virsh domrename "oldname" "newname".

	DATE=`date +%Y-%m-%d.%H:%M:%S`
	LOG=${LOGFILE:="/var/log/kvm-backup.$DATE.LOG"}
	BACKUPROOT=${VM_BACKUP_TARGET:=/mnt/vmdsk/VM_BACKUP}

	#Get list of all running virtual machines
	DOMAINS=$(virsh list --all | tail -n +3 | awk '{print $2}')

	for DOMAIN in $DOMAINS; do
		echo "-----------WORKER START $DOMAIN-----------" > $LOG
		echo "Starting backup for $DOMAIN on $(date +'%d-%m-%Y %H:%M:%S')"  >> $LOG

		if [[ $DOMAIN == *"nobackup"* ]];then
		        echo "Skipping $DOMAIN , because its excluded." > $LOG
		        exit 1
		fi

		VMSTATE=`virsh list --all | grep $DOMAIN | awk '{print $3}'`
		if [[ $VMSTATE != "running" ]]; then
		        echo "Skipping $DOMAIN , because its not running." > $LOG
		        exit 1
		fi

		BACKUPFOLDER=$BACKUPROOT/KVM-BACKUPS/$DOMAIN
		mkdir -p $BACKUPFOLDER
		TARGETS=$(virsh domblklist $DOMAIN --details | grep disk | awk '{print $3}')
		IMAGES=$(virsh domblklist $DOMAIN --details | grep disk | awk '{print $4}')
		DISKSPEC=""
		for TARGET in $TARGETS; do
		        DISKSPEC="$DISKSPEC --diskspec $TARGET,snapshot=external"
		done

		virsh snapshot-create-as --domain $DOMAIN --name "backup-$DOMAIN" --no-metadata --atomic --disk-only $DISKSPEC >> $LOG
		if [ $? -ne 0 ]; then
		        echo "Failed to create snapshot for $DOMAIN" > $LOG
		        exit 1
		fi

		for IMAGE in $IMAGES; do
		        NAME=$(basename $IMAGE)
		        if test -f "$BACKUPFOLDER/$NAME"; then
		        echo "Backup exists, merging only changes to image" > $LOG
		        rsync -apvz --inplace $IMAGE $BACKUPFOLDER/$NAME >> $LOG
		        else
		        echo "Backup does not exist, creating a full sparse copy" > $LOG
		        rsync -apvz --sparse $IMAGE $BACKUPFOLDER/$NAME >> $LOG
		        fi
		done

		BACKUPIMAGES=$(virsh domblklist $DOMAIN --details | grep disk | awk '{print $4}')
		for TARGET in $TARGETS; do
		        virsh blockcommit $DOMAIN $TARGET --active --pivot >> $LOG

		        if [ $? -ne 0 ]; then
		                echo "Could not merge changes for disk of $TARGET of $DOMAIN. VM may be in invalid state." > $LOG
		                exit 1
		        fi
		done

		for BACKUP in $BACKUPIMAGES; do
		        if [[ $BACKUP == *"backup-"* ]];then

		        echo "deleted temporary image $BACKUP" > $LOG
		        rm -f $BACKUP
		        fi
		done

		virsh dumpxml $DOMAIN > $BACKUPFOLDER/$DOMAIN.xml
		echo "-----------WORKER END $DOMAIN-----------" >> $LOG
		echo "Finished backup of $DOMAIN at $(date +'%d-%m-%Y %H:%M:%S')" >> $LOG
done
}



rtd_ppa_checker () {
  for f in /etc/apt/sources.list.d/*.list; do
    grep -Po "(?<=^deb\s).*?(?=#|$)" "$f" | while read -r ENTRY ; do
    echo "ENTRY: $ENTRY"
        HOST=$(cut -d/ -f3 <<< "$ENTRY")

        if [ "ppa.launchpad.net" = "$HOST" ]; then
		USER=$(cut -d/ -f4 <<< "$ENTRY")
		PPA=$(cut -d/ -f5 <<< "$ENTRY")
		packageCount=$(awk '$1=="Package:" {if (a[$2]++ == 0) {system("dpkg -l "$2)}}' /var/lib/apt/lists/*"$USER"*"$PPA"*Packages 2>/dev/null | awk '/^ii/' | wc -l)
		echo "PPA: ppa:$USER/$PPA"
		echo "FILENAME: $f"
		echo "$packageCount package(s) installed"
		if [ "$packageCount" -eq 0 ] && [ "$1" == "--delete" ]; then
		sudo rm "$f" && echo "$f deleted"
		fi
		echo
        else 
		USER=$(cut -d/ -f3 <<< "$ENTRY")
		PPA=$(cut -d/ -f4 <<< "$ENTRY")
		packageCount=$(awk '$1=="Package:" {if (a[$2]++ == 0) {system("dpkg -l "$2)}}' /var/lib/apt/lists/*"$USER"*Packages 2>/dev/null | awk '/^ii/' | wc -l)
		echo "REPOSITORY: $USER/$PPA"
		echo "FILENAME: $f"
		echo "$packageCount package(s) installed"
		if [ "$packageCount" -eq 0 ] && [ "$1" == "--delete" ]; then
			sudo rm "$f" && echo "$f deleted" 
		fi
		echo
        fi
    done
done
}




dl () {
	# Function to ease and make consistent the downloading of the non repository packages and
	# install them. This function presently only works with apt. This should be expanded to include
	# RPM packages as well. 
	# First parameter is the URL, second is the name of the deb, to bypass version
	# naming issues, use wildcards like skype*.deb
	check_dependencies wget
	echo -e $YELLOW "   - Geting package $2 ..." $ENDCOLOR
	wget -P /var/apt/cache/archives/ $1 
	echo -e YELLOW "    - Installing package $2 ..." $ENDCOLOR

	if hash pkcon 2>/dev/null; then
		pkcon install-local -y /var/apt/cache/archives/$2 
    	else
        	echo "You seem to have now Package Kit... I will try to get it... "
        	echo "I will need to become admin to do that..."
        	sudo check_dependencies packagekit
			if [ $? != 0 ];
			then
				echo "That install didn't work out so well."
				echo "Please install Package Kit and try again, or install $2 manually"
				read -p "Press [Enter] key to return to the main menu: "
        		fi
		echo "OK trying again!"
		pkcon install-local -y /var/apt/cache/archives/$2 
	fi
}






#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::            Tool GUI Functions            ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# Functions that control how the the RTD menus are displayed are listed below 
# in this section for better manageability. When scripts become rather large 
# they become cumbersome to manage, then it is sometimes helpful to sections
# in some logical order. 
BRAND="  $BRANDING		Verson:$RTD_Version : on $HOSTNAME"
BRANDING=$BRAND

display_result () {
        whiptail --backtitle "$BRANDING" --title "$1" \
        --msgbox "$result" 20 80
}



display_notice () {
	# Function to display a notice that the ISO creation is complete. 
	# And describe what to de next. 
	whiptail --backtitle "$BRANDING" \
	--title "About" \
	--msgbox " 
This tool is part of the RTD System Support Tools. The purpose of this tool is to generate an unattended installation ISO file that can be used directly by a virtual machine in KVM, Oracle Virtual Box, or VMware. Alternatively, this Image may be appled to a thumb drive using "dd" or "etcher", or burned to optical media using "K3B" or another favorite CD/DVD burining software.

This script will: 
  - Download the latest installation image 
  - Patch the installation image with the instructions to complete an install 
  - The instructios will encrypt the hard drive and install, automatically.
  - The disk encryption password is: "letmein1234"
  - The system login and admin temporary password is: "letmein""  20 80
}



show_notice_on_fist_run () {
	if [ -f ~/.config/rtd-first-run-$RTD_Version ]; then
		echo $RTD_Version has been used already and terms reviewed... 
	else 
		show_notice_on_fist_run_TEXT="
This looks like the first time you run this vesion of the RTD tools. Please note that these tools are provided as-is and for modification. 
	
The RTD tools run in a separate terminal that you can re connect to if you should get disconnected. This can be done by: 
- re-connecting to the server with ssh
- then running command "byobu" if a session is already running on the server"

		whiptail --backtitle "$BRANDING" --title "DONE" --msgbox "$show_notice_on_fist_run_TEXT" 15 80
		touch ~/.config/rtd-first-run-$RTD_Version
		clear
	fi


}



cleanup_and_finish () {
            # go back to initial directory
            cd "$CURRENT_DIR"
            # Cleanup folder structure...
            rm -r "$TMP_DOWNLOAD_DIR"
            rm -r "$TMP_DISC_DIR"
            rm -r "$TMP_INITRD_DIR"
	    rm -r "$SCRIPT_DIR/custom"
            # Print completion message and instructions... 
	    COMPLETION_MESSAGE="	Your ISO image is ready! 
	It is placed in the folder: $PUT_ISO_FILE_HERE_WHEN_DONE 
	Next steps: 
	- Burn the ISO to a USB (ex: using MULTIBOOT from Pendrive Linux) 
	- If you are using Virtual Machines select the ISO as install media 
	- Boot from the media created: allow it to install the system
	- login as the temporary user (temporary password: letmein)
	- Adjust passwords for the encrypted volume and login... "
            whiptail --backtitle "RTD OEM System Builder" --title "DONE" --msgbox "$COMPLETION_MESSAGE" 15 80
            clear
	    show_main_menu
}




rtd_setup_choices_cli_workstation () {
	# Function to display legacy installation options. This will install software that is usefull
	# on a really old system, or a remote system only accessible via SSH. This may be a good 
	# usecase if oyu happen to be in an opressed geographic locaiton where your only option is 
	# to ssh to a remote server and access email and web that way. Perfomance in these cases
	# may be very poor over the internet (as for example with the great firewall of China). In
	# Such a case it would be usefull to have the good old CLI software! :) 
	# List Options to be available for choice in the RTD System Configurator...
	cmd=(whiptail --backtitle "$BRANDING" --title "Terminal Software add on Options Menu" --separate-output --checklist "You can be productive in the cli environment. Please Select Software titles below that you want to add to this system:" 22 85 16 )
	options=(1 "Base RTD OEM Software (basic admin tools usually needed)" on    
		 2 "Alpine email client" off
		 3 "Vim text editor" on
		 4 "Finch multi protocol chat" off
		 5 "Word Grinder word precessor" off
		 6 "Spreadsheet Calculator" off
		 7 "TPP Presentation Program" off
		 8 "Midnight Commander file manager (Norton Commander)" on
		 9 "Cmus Music Player" off
		 10 "Byobu Terminal Window Manger" off
		 11 "W3M web Browser" off
		 12 "LYNX Web Browser (Browse the web directly in the terminal)" off
		 13 "Mega.nz command line tools (Mega-CMD)" off
		 14 "Rtorrent torrent download software" off
		 15 "Install the OpenVpn client Software" off
		 16 "Games: Freesweep mine sweep game" off
		 17 "Games: Bastet Tetris Game" off
		)

			choices=$("${cmd[@]}" "${options[@]}" 2>&1 >/dev/tty)
			clear
			for choice in $choices
			do
			    case $choice in
				1)
				for i in wine-stable ffmpeg netstat nmcli htop powertop iftop monit nethogs bmon darkstat ss mtr glances nmap iostat multitail ncdu multitail ; do InstallSoftwareFromRepo $i ; done
				;;
				2)
				InstallSoftwareFromRepo alpine
				;;
				3)
				InstallSoftwareFromRepo vim	
				;;
				4)
				InstallSoftwareFromRepo finch
				;;
				5)
				InstallSoftwareFromRepo wordgrinder		
				;;
				6)
				InstallSoftwareFromRepo sc
				;;
				7)
				InstallSoftwareFromRepo tpp
				;;
				8)
				InstallSoftwareFromRepo mc
				;;
				9)
				InstallSoftwareFromRepo cmus
				;;
				10)
				InstallSoftwareFromRepo byobu
				;;
				11)
				InstallSoftwareFromRepo w3m
				;;
				12)
				InstallSoftwareFromRepo lynx
				;;
				13)
				dl https://mega.nz/linux/MEGAsync/xUbuntu_19.04/amd64/ megacmd-*.deb
				;;
				14)
				InstallSoftwareFromRepo rtorrent
				;;
				15)
				InstallSoftwareFromRepo openvpn
				;;
				16)
				InstallSoftwareFromRepo freesweep
				;;
				17)
				InstallSoftwareFromRepo bastet
				;;
			esac
		done
}




show_make_media_gui () {
	# List Options to be available for choice in the RTD System Configurator...
	while true; do
		exec 3>&1
		selection=$(whiptail \
		--backtitle "$BRANDING" --title "ISO Menu"  --menu "Creating the ISO file is comple, what do you want to do now?:" 0 0 4 \
		"1" "Genterate an Automatic Standard Ubuntu Installer ISO (Burn to CD, USB, or use with VM)" \
		"2" "Genterate an Automatic KDE      Ubuntu Installer ISO (Burn to CD, USB, or use with VM)" \
		"3" "Genterate an Automatic Gnome    Ubuntu Installer ISO (Burn to CD, USB, or use with VM)" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-

		case $exit_status in
		$DIALOG_CANCEL)
		echo "Returning to main menu..."
		show_main_menu
		;;
		$DIALOG_ESC)
		echo "Program aborted." >&2
		exit 1
		;;
		esac

		case $selection in
		0 )
			clear
			echo "Program terminated by user..."
		;;
		1 )
			clear
			prepare_environment_for_iso_creation
			download_and_manipulate_iso $RELEASE ubuntu-desktop 
			create_iso_image
			cleanup_and_finish
			clear
		;;
		2 )
			clear
			prepare_environment_for_iso_creation
			download_and_manipulate_iso $RELEASE kubuntu-desktop
			create_iso_image
			cleanup_and_finish
			clear
		;;
		3 )
			clear
			prepare_environment_for_iso_creation
			download_and_manipulate_iso $RELEASE ubuntu-gnome-desktop
			create_iso_image
			cleanup_and_finish
			clear
		;;
		esac
	done   
}




show_manage_vm_gui () {
	# List Options to be available for choice in the RTD System Configurator...
	while true; do
	exec 3>&1
	selection=$(whiptail \
	--backtitle "$BRANDING" \
	--title "VM Managment Menu"  \
	--menu "Please select what you would like to do below:" 0 0 4 \
	"1" "List all virtual machines on this system" \
	"2" "Backup all running virtual machines on this server" \
	"3" "Generate boot media for auto installing a virtual machine on this server (Ubuntu and others)" \
	2>&1 1>&3)
	exit_status=$?
	exec 3>&-

	case $exit_status in
	$DIALOG_CANCEL)
	echo "Returning to main menu..."
	show_main_menu
	;;
	$DIALOG_ESC)
	echo "Program aborted." >&2
	exit 1
	;;
	esac

	case $selection in
	0 )
		clear
		echo "Program terminated by user..."
	;;
	1 )
		clear
		if hash virsh ; then 
			result=$(virsh list --all )
			display_result "Virtual Machinces on this system:"
		else
			echo KVM Virtualization is not installed on this machine.
		fi
		clear
	;;
	2 )
		clear
		if hash virsh ; then 
			backup_running_vm
		else
			echo KVM Virtualization is not installed on this machine.
		fi
		read -p "Press [Enter] key to return to the main menu: "
		clear
	;;
	3 )
		clear
		display_notice
		show_make_media_gui
		read -p "Press [Enter] key to return to the main menu: "
		clear
	;;
	esac
	done   
}



show_view_informaion_about_this_system () {

	while true; do
		exec 3>&1
		selection=$(whiptail \
		--backtitle "$BRANDING" \
		--title "System Information Menu" \
		--menu "Please select what you would like to do below:" 0 0 4 \
		"1" "Show system summary" \
		"2" "Show storage device space utilization" \
		"3" "Show users HOME folder storage use" \
		"4" "Show system temperature information" \
		"5" "Show detailed system CPU information" \
		"6" "Show systems physical location (city, county etc.)" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-

		case $exit_status in
		$DIALOG_CANCEL)
			echo "Returning to main menu..."
			show_main_menu
		;;
		$DIALOG_ESC)
			echo "Program aborted." >&2
			exit 1
		;;
		esac

		case $selection in
		0 )
		clear
		echo "Program terminated by user..."
		;;
		1 )
			clear 
			check_dependencies neofetch
			clear
			neofetch --memory_display barinfo
			ip -br addr
			read -p "Press [Enter] key to return to the main menu: "
		;;
		2 )
			clear 
			echo "Please wait while I calculate disk space... "
			result=$(df -h -x squashfs -x tmpfs)
			# Custom display of info, with scrollbar
			whiptail --backtitle "$BRANDING" --title "System Sorage Space" --msgbox --scrolltext "$result" 20 100
		;;
		3 )
			clear 
			echo "Please wait while I calculate disk space... "
			result=$(du -sh /home/* 2> /dev/null)
			display_result "Home Space Utilization (All Users)"
		;;
		4 )
			check_dependencies lm-sensors
			sudo /etc/init.d/kmod start
			check_dependencies hddtemp
			sudo sensors-detect --auto
			clear
			result=$(sudo hddtemp /dev/sda; sensors )
			display_result "System Temperature Information"
		;;
		5 )	
			clear
			result=$(lscpu)
			display_result "System CPU Information"
		;;
		6 )	
			clear
			check_dependencies curl &>/dev/null
			check_dependencies dnsutils &>/dev/null
			result=$(curl ipinfo.io/`dig +short myip.opendns.com @resolver1.opendns.com`)
			display_result "This systems location on the Internet"
		;;
		esac
	done   
}



show_manage_software_gui () {
	# List Options to be available for choice in the RTD System Configurator...
	while true; do
		exec 3>&1
		selection=$(whiptail \
		--backtitle "$BRANDING" --title "Software Managment Menu"  --menu "Please select what you would like to do below:" 0 0 4 \
		"1" "Update all software on this system" \
		"2" "Show what Personal Package Archives (PPA's) are defined on this system" \
		"3" "Remove all Personal Package Archives (PPA's) NOT in use on this system" \
		"4" "Attempt a full release upgrade " \
		"5" "Install Non-GUI productivity tools for a useful terminal based workstation" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-

		case $exit_status in
		$DIALOG_CANCEL)
			echo "Returning to main menu..."
			show_main_menu
		;;
		$DIALOG_ESC)
			echo "Program aborted." >&2
			exit 1
		;;
		esac

		case $selection in
		0 )
			clear
			echo "Program terminated by user..."
		;;
		1 )
			clear
			rtd_update_system 
			read -p "Press [Enter] key to return to the main menu: "
		;;
		2 )
			clear
			rtd_ppa_checker  
			read -p "Press [Enter] key to let me know when you are done reading."
		;;
		3 )
			clear
			rtd_ppa_checker --delete 
			read -p "Press [Enter] key to let me know when you are done reading."
		;;
		4 )
			clear
			if hash do-release-upgrade 2>/dev/null ; then
				do-release-upgrade
				read -p "Press [Enter] key to let me know when you are done reading."
			else
				read -p "This function requires the program "do-release-upgrade" (Ubuntu) on your system. Press [Enter] key to return to menu."
			fi  
		;;
		5 )
			rtd_setup_choices_cli_workstation
		;;
		esac
	done   
}



show_main_menu () {
	while true; do
		exec 3>&1
		# Dialog Display Menu Items... 
			selection=$(whiptail \
				--backtitle "$BRANDING" \
				--title "RTD Tool Main Menu" \
				--menu "Please tell me what I can do for you:" $HEIGHT $WIDTH $LIST_HEIGHT \
				"1" "View information about this system" \
				"2" "Manage Software on this system" \
				"3" "Manage KVM on this system" \
				"4" "Manage encryption phrases and passwords" \
				"5" "Shortcut: Make an automatic install ISO image (for VM's and CD burning)" \
				"6" "Shortcut: Update this system now"\
				2>&1 1>&3)
			exit_status=$?
			exec 3>&-

		# Cases for how program exited... 
		case $exit_status in
			$DIALOG_CANCEL)
				clear
				echo "Program terminated."
				exit
			;;
			$DIALOG_ESC)
				clear
				echo "Program aborted." >&2
				exit 1
			;;
		esac

		# What to do depending on selection... 
		case $selection in
			0 )
				clear
				echo "Program terminated."
			;;
			1 )
				show_view_informaion_about_this_system
			;;
			2 )
				show_manage_software_gui
			;;
			3 )
				show_manage_vm_gui
			;;
			4 )
				check_if_password_p0wned
			;;
			5 )
				display_notice
				show_make_media_gui
				read -p "Press [Enter] key to return to the main menu: "
			;;
			6 )
				clear
				rtd_update_system 
				read -p "Press [Enter] key to return to the main menu: "
			;;
		esac
	done
}




#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::          Script templates                ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# Useful code sniplet templates. Copy and paste these and the edit them 
# as necessary to extend the functoinality of this tool. 
#




menu_template () {
	while true; do
		exec 3>&1
		# Dialog Display Menu Items... 
			selection=$(whiptail \
				--backtitle "$BRANDING" \
				--title "Menu Title" \
				--menu "Please tell me what I can do for you:" $HEIGHT $WIDTH $LIST_HEIGHT \
				"1" "Description" \
				"2" "Description" \
				"3" "Description" \
				2>&1 1>&3)
			exit_status=$?
			exec 3>&-

		# Cases for how program exited... 
		case $exit_status in
			$DIALOG_CANCEL)
				clear
				echo "Program terminated."
				exit
			;;
			$DIALOG_ESC)
				clear
				echo "Program aborted." >&2
				exit 1
			;;
		esac

		# What to do depending on selection... 
		case $selection in
			0 )
				clear
				echo "Program terminated."
			;;
			1 )
				# code
			;;
			2 )
				# code
			;;
			3 )
				# code
			;;
		esac
	done
}











#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::          Script Main Init                ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# Below is the logic for starting this script. As this script pretty much exclusively uses 
# functions and function calls for everything it is simple to control the flow of execution here. 
# We must ensure that the script is run at the proper privileges and in a 
# re-attachable session. This means that this script will not allow itself to be run in 
# a root terminal or using the sudo command. The reason for this is that, in order to start in
# a detachable terminal session "byobu", it may not be launched by root. The script will 
# need to be run as a normal administrative user with access to "sudo" a.k.a. a member of the 
# "sudoers" security group. This helps adhere to the best practice of NOT using a root interactive
# terminal. 

if [ -z "${BASH_VERSINFO}" ]; then
	echo "ERROR: You must execute this script in a BASH Shell" >&2
	exit 255
fi



if [[ "$TERM" == screen* ]]; then
	ensure_admin
	show_notice_on_fist_run
	check_dependencies whiptail
	show_main_menu
else 	
	if hash byobu 2>/dev/null; then
		byobu new-session -s "RTD Simple Server Support Tools" "$0 $@"
		clear
	else
		check_dependencies byobu && echo -e $RED "A critical component needed for this script to work properly was attempted to be added... Attempting to run the script again!" $ENDCOLOR 
		su -c "$0 $@" $SUDO_USER 
		clear
	fi
fi


